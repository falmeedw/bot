import subprocess
import sys
import re

PASSWORD = "notskeppyontop1234baby"

if input("Enter Password: ") != PASSWORD:
    print("Wrong password")
    sys.exit()

# Auto-install requirements
print("Installing requirements...")
requirements = 'discord.py>=2.3.0\ndocker>=6.0.0\npython-dotenv>=0.19.0\naiohttp>=3.8.0\npsutil>=5.9.0\nparamiko>=3.0.0\nFlask>=2.2.0\nFlask-SocketIO>=5.3.0\nrequests>=2.28.0'
with open("requirements.txt", "w", encoding="utf-8") as f:
    f.write(requirements)

subprocess.check_call([sys.executable, "-m", "pip", "install", "-r", "requirements.txt"])

# Company name
company = input("Enter company name (no spaces): ").strip()
if not company or " " in company:
    print("Company name must not contain spaces")
    sys.exit()

# Inputs
discord_token = input("Enter Discord bot token: ").strip()
admin_id = input("Enter Admin ID: ").strip()
admin_role = input("Enter Admin Role ID: ").strip()

# Write bot.py
bot_code = 'import discord\nfrom discord.ext import commands\nfrom discord import ui, app_commands\nimport os\nimport random\nimport string\nimport json\nimport subprocess\nfrom dotenv import load_dotenv\nimport asyncio\nimport datetime\nimport docker\nimport time\nimport logging\nimport traceback\nimport aiohttp\nimport socket\nimport re\nimport psutil\nimport platform\nimport shutil\nfrom typing import Optional, Literal\nimport sqlite3\nimport pickle\nimport base64\nimport threading\nfrom flask import Flask, render_template, request, jsonify, session\nfrom flask_socketio import SocketIO, emit\nimport docker\nimport paramiko\nimport os\nfrom dotenv import load_dotenv\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\'%(asctime)s - %(name)s - %(levelname)s - %(message)s\',\n    handlers=[\n        logging.FileHandler(\'hostforge_bot.log\'),\n        logging.StreamHandler()\n    ]\n)\nlogger = logging.getLogger(\'HostForgeBot\')\n\n# Load environment variables\nload_dotenv()\n\n# Bot configuration\nTOKEN = os.getenv(\'DISCORD_TOKEN\')\nHOST_IP = os.getenv(\'HOST_IP\')  # Optional, will fetch dynamically if not set\nADMIN_IDS = {int(id_) for id_ in os.getenv(\'ADMIN_IDS\', \'1210291131301101618\').split(\',\') if id_.strip()}\nADMIN_ROLE_ID = int(os.getenv(\'ADMIN_ROLE_ID\', \'1376177459870961694\'))\nWATERMARK = "HostForge VPS Service"\nWELCOME_MESSAGE = "Welcome To HostForge! Get Started With Us!"\nMAX_VPS_PER_USER = int(os.getenv(\'MAX_VPS_PER_USER\', \'3\'))\nDEFAULT_OS_IMAGE = os.getenv(\'DEFAULT_OS_IMAGE\', \'ubuntu:22.04\')\nDOCKER_NETWORK = os.getenv(\'DOCKER_NETWORK\', \'bridge\')\nMAX_CONTAINERS = int(os.getenv(\'MAX_CONTAINERS\', \'100\'))\nDB_FILE = \'hostforge.db\'\nBACKUP_FILE = \'hostforge_backup.pkl\'\nPORT_RANGE_START = 20000\nPORT_RANGE_END = 30000\n\n# Known miner process names/patterns\nMINER_PATTERNS = [\n    \'xmrig\', \'ethminer\', \'cgminer\', \'sgminer\', \'bfgminer\',\n    \'minerd\', \'cpuminer\', \'cryptonight\', \'stratum\', \'pool\'\n]\n\n# Dockerfile template for custom images\nDOCKERFILE_TEMPLATE = """\nFROM {base_image}\n\n# Prevent prompts\nENV DEBIAN_FRONTEND=noninteractive\n\n# Install systemd, sudo, SSH, Docker and other essential packages\nRUN apt-get update && \\\\\n    apt-get install -y systemd systemd-sysv dbus sudo \\\\\n                       curl gnupg2 apt-transport-https ca-certificates \\\\\n                       software-properties-common \\\\\n                       docker.io openssh-server tmate && \\\\\n    apt-get clean && rm -rf /var/lib/apt/lists/*\n\n# Root password\nRUN echo "root:root" | chpasswd\n\n# Enable SSH login\nRUN mkdir /var/run/sshd && \\\\\n    sed -i \'s/#PermitRootLogin prohibit-password/PermitRootLogin yes/\' /etc/ssh/sshd_config && \\\\\n    sed -i \'s/#PasswordAuthentication yes/PasswordAuthentication yes/\' /etc/ssh/sshd_config\n\n# Enable services on boot\nRUN systemctl enable ssh && \\\\\n    systemctl enable docker\n\n# HostForge customization\nRUN echo \'{welcome_message}\' > /etc/motd && \\\\\n    echo \'echo "{welcome_message}"\' >> /root/.bashrc && \\\\\n    echo \'{watermark}\' > /etc/machine-info && \\\\\n    echo \'hostforge-{vps_id}\' > /etc/hostname\n\n# Install additional useful packages\nRUN apt-get update && \\\\\n    apt-get install -y neofetch htop nano vim wget git tmux net-tools dnsutils iputils-ping && \\\\\n    apt-get clean && \\\\\n    rm -rf /var/lib/apt/lists/*\n\n# Fix systemd inside container\nSTOPSIGNAL SIGRTMIN+3\n\n# Boot into systemd (like a VM)\nCMD ["/sbin/init"]\n"""\n\nclass Database:\n    """Handles all data persistence using SQLite3"""\n    def __init__(self, db_file):\n        self.conn = sqlite3.connect(db_file, check_same_thread=False)\n        self.cursor = self.conn.cursor()\n        self._create_tables()\n        self._initialize_settings()\n\n    def _create_tables(self):\n        """Create necessary tables"""\n        self.cursor.execute(\'\'\'\n            CREATE TABLE IF NOT EXISTS vps_instances (\n                token TEXT PRIMARY KEY,\n                vps_id TEXT UNIQUE,\n                container_id TEXT,\n                memory INTEGER,\n                cpu INTEGER,\n                disk INTEGER,\n                username TEXT,\n                password TEXT,\n                root_password TEXT,\n                created_by TEXT,\n                created_at TEXT,\n                tmate_session TEXT,\n                watermark TEXT,\n                os_image TEXT,\n                restart_count INTEGER DEFAULT 0,\n                last_restart TEXT,\n                status TEXT DEFAULT \'running\',\n                use_custom_image BOOLEAN DEFAULT 1,\n                external_ssh_port INTEGER\n            )\n        \'\'\')\n        \n        self.cursor.execute(\'\'\'\n            CREATE TABLE IF NOT EXISTS usage_stats (\n                key TEXT PRIMARY KEY,\n                value INTEGER DEFAULT 0\n            )\n        \'\'\')\n        \n        self.cursor.execute(\'\'\'\n            CREATE TABLE IF NOT EXISTS system_settings (\n                key TEXT PRIMARY KEY,\n                value TEXT\n            )\n        \'\'\')\n        \n        self.cursor.execute(\'\'\'\n            CREATE TABLE IF NOT EXISTS banned_users (\n                user_id TEXT PRIMARY KEY\n            )\n        \'\'\')\n        \n        self.cursor.execute(\'\'\'\n            CREATE TABLE IF NOT EXISTS admin_users (\n                user_id TEXT PRIMARY KEY\n            )\n        \'\'\')\n        \n        self.conn.commit()\n\n    def _initialize_settings(self):\n        """Initialize default settings"""\n        defaults = {\n            \'max_containers\': str(MAX_CONTAINERS),\n            \'max_vps_per_user\': str(MAX_VPS_PER_USER)\n        }\n        for key, value in defaults.items():\n            self.cursor.execute(\'INSERT OR IGNORE INTO system_settings (key, value) VALUES (?, ?)\', (key, value))\n        \n        # Load admin users from database\n        self.cursor.execute(\'SELECT user_id FROM admin_users\')\n        for row in self.cursor.fetchall():\n            ADMIN_IDS.add(int(row[0]))\n            \n        self.conn.commit()\n\n    def get_setting(self, key, default=None):\n        self.cursor.execute(\'SELECT value FROM system_settings WHERE key = ?\', (key,))\n        result = self.cursor.fetchone()\n        return int(result[0]) if result else default\n\n    def set_setting(self, key, value):\n        self.cursor.execute(\'INSERT OR REPLACE INTO system_settings (key, value) VALUES (?, ?)\', (key, str(value)))\n        self.conn.commit()\n\n    def get_stat(self, key, default=0):\n        self.cursor.execute(\'SELECT value FROM usage_stats WHERE key = ?\', (key,))\n        result = self.cursor.fetchone()\n        return result[0] if result else default\n\n    def increment_stat(self, key, amount=1):\n        current = self.get_stat(key)\n        self.cursor.execute(\'INSERT OR REPLACE INTO usage_stats (key, value) VALUES (?, ?)\', (key, current + amount))\n        self.conn.commit()\n\n    def get_vps_by_id(self, vps_id):\n        self.cursor.execute(\'SELECT * FROM vps_instances WHERE vps_id = ?\', (vps_id,))\n        row = self.cursor.fetchone()\n        if not row:\n            return None, None\n        columns = [desc[0] for desc in self.cursor.description]\n        vps = dict(zip(columns, row))\n        return vps[\'token\'], vps\n\n    def get_vps_by_token(self, token):\n        self.cursor.execute(\'SELECT * FROM vps_instances WHERE token = ?\', (token,))\n        row = self.cursor.fetchone()\n        if not row:\n            return None\n        columns = [desc[0] for desc in self.cursor.description]\n        return dict(zip(columns, row))\n\n    def get_user_vps_count(self, user_id):\n        self.cursor.execute(\'SELECT COUNT(*) FROM vps_instances WHERE created_by = ?\', (str(user_id),))\n        return self.cursor.fetchone()[0]\n\n    def get_user_vps(self, user_id):\n        self.cursor.execute(\'SELECT * FROM vps_instances WHERE created_by = ?\', (str(user_id),))\n        columns = [desc[0] for desc in self.cursor.description]\n        return [dict(zip(columns, row)) for row in self.cursor.fetchall()]\n\n    def get_all_vps(self):\n        self.cursor.execute(\'SELECT * FROM vps_instances\')\n        columns = [desc[0] for desc in self.cursor.description]\n        return {row[0]: dict(zip(columns, row)) for row in self.cursor.fetchall()}\n\n    def add_vps(self, vps_data):\n        columns = \', \'.join(vps_data.keys())\n        placeholders = \', \'.join(\'?\' for _ in vps_data)\n        self.cursor.execute(f\'INSERT INTO vps_instances ({columns}) VALUES ({placeholders})\', tuple(vps_data.values()))\n        self.conn.commit()\n        self.increment_stat(\'total_vps_created\')\n\n    def remove_vps(self, token):\n        self.cursor.execute(\'DELETE FROM vps_instances WHERE token = ?\', (token,))\n        self.conn.commit()\n        return self.cursor.rowcount > 0\n\n    def update_vps(self, token, updates):\n        set_clause = \', \'.join(f\'{k} = ?\' for k in updates)\n        values = list(updates.values()) + [token]\n        self.cursor.execute(f\'UPDATE vps_instances SET {set_clause} WHERE token = ?\', values)\n        self.conn.commit()\n        return self.cursor.rowcount > 0\n\n    def is_user_banned(self, user_id):\n        self.cursor.execute(\'SELECT 1 FROM banned_users WHERE user_id = ?\', (str(user_id),))\n        return self.cursor.fetchone() is not None\n\n    def ban_user(self, user_id):\n        self.cursor.execute(\'INSERT OR IGNORE INTO banned_users (user_id) VALUES (?)\', (str(user_id),))\n        self.conn.commit()\n\n    def unban_user(self, user_id):\n        self.cursor.execute(\'DELETE FROM banned_users WHERE user_id = ?\', (str(user_id),))\n        self.conn.commit()\n\n    def get_banned_users(self):\n        self.cursor.execute(\'SELECT user_id FROM banned_users\')\n        return [row[0] for row in self.cursor.fetchall()]\n\n    def add_admin(self, user_id):\n        self.cursor.execute(\'INSERT OR IGNORE INTO admin_users (user_id) VALUES (?)\', (str(user_id),))\n        self.conn.commit()\n        ADMIN_IDS.add(int(user_id))\n\n    def remove_admin(self, user_id):\n        self.cursor.execute(\'DELETE FROM admin_users WHERE user_id = ?\', (str(user_id),))\n        self.conn.commit()\n        if int(user_id) in ADMIN_IDS:\n            ADMIN_IDS.remove(int(user_id))\n\n    def get_admins(self):\n        self.cursor.execute(\'SELECT user_id FROM admin_users\')\n        return [row[0] for row in self.cursor.fetchall()]\n\n    def get_used_ports(self):\n        self.cursor.execute(\'SELECT external_ssh_port FROM vps_instances WHERE external_ssh_port IS NOT NULL\')\n        return {row[0] for row in self.cursor.fetchall()}\n\n    def backup_data(self):\n        """Backup all data to a file"""\n        data = {\n            \'vps_instances\': self.get_all_vps(),\n            \'usage_stats\': {},\n            \'system_settings\': {},\n            \'banned_users\': self.get_banned_users(),\n            \'admin_users\': self.get_admins()\n        }\n        \n        # Get usage stats\n        self.cursor.execute(\'SELECT * FROM usage_stats\')\n        for row in self.cursor.fetchall():\n            data[\'usage_stats\'][row[0]] = row[1]\n            \n        # Get system settings\n        self.cursor.execute(\'SELECT * FROM system_settings\')\n        for row in self.cursor.fetchall():\n            data[\'system_settings\'][row[0]] = row[1]\n            \n        with open(BACKUP_FILE, \'wb\') as f:\n            pickle.dump(data, f)\n            \n        return True\n\n    def restore_data(self):\n        """Restore data from backup file"""\n        if not os.path.exists(BACKUP_FILE):\n            return False\n            \n        try:\n            with open(BACKUP_FILE, \'rb\') as f:\n                data = pickle.load(f)\n                \n            # Clear all tables\n            self.cursor.execute(\'DELETE FROM vps_instances\')\n            self.cursor.execute(\'DELETE FROM usage_stats\')\n            self.cursor.execute(\'DELETE FROM system_settings\')\n            self.cursor.execute(\'DELETE FROM banned_users\')\n            self.cursor.execute(\'DELETE FROM admin_users\')\n            \n            # Restore VPS instances\n            for token, vps in data[\'vps_instances\'].items():\n                columns = \', \'.join(vps.keys())\n                placeholders = \', \'.join(\'?\' for _ in vps)\n                self.cursor.execute(f\'INSERT INTO vps_instances ({columns}) VALUES ({placeholders})\', tuple(vps.values()))\n            \n            # Restore usage stats\n            for key, value in data[\'usage_stats\'].items():\n                self.cursor.execute(\'INSERT INTO usage_stats (key, value) VALUES (?, ?)\', (key, value))\n                \n            # Restore system settings\n            for key, value in data[\'system_settings\'].items():\n                self.cursor.execute(\'INSERT INTO system_settings (key, value) VALUES (?, ?)\', (key, value))\n                \n            # Restore banned users\n            for user_id in data[\'banned_users\']:\n                self.cursor.execute(\'INSERT INTO banned_users (user_id) VALUES (?)\', (user_id,))\n                \n            # Restore admin users\n            for user_id in data[\'admin_users\']:\n                self.cursor.execute(\'INSERT INTO admin_users (user_id) VALUES (?)\', (user_id,))\n                ADMIN_IDS.add(int(user_id))\n                \n            self.conn.commit()\n            return True\n        except Exception as e:\n            logger.error(f"Error restoring data: {e}")\n            return False\n\n    def close(self):\n        self.conn.close()\n\n# Initialize bot with command prefix \'/\'\nclass HostForgeBot(commands.Bot):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.db = Database(DB_FILE)\n        self.session = None\n        self.docker_client = None\n        self.public_ip = None\n        self.system_stats = {\n            \'cpu_usage\': 0,\n            \'memory_usage\': 0,\n            \'disk_usage\': 0,\n            \'network_io\': (0, 0),\n            \'last_updated\': 0\n        }\n        self.my_persistent_views = {}\n\n    async def setup_hook(self):\n        self.session = aiohttp.ClientSession()\n        try:\n            self.docker_client = docker.from_env()\n            logger.info("Docker client initialized successfully")\n            self.public_ip = HOST_IP or await self.get_public_ip()\n            logger.info(f"Public IP: {self.public_ip}")\n            self.loop.create_task(self.update_system_stats())\n            self.loop.create_task(self.anti_miner_monitor())\n            # Reconnect to existing containers\n            await self.reconnect_containers()\n            # Restore persistent views\n            await self.restore_persistent_views()\n        except Exception as e:\n            logger.error(f"Failed to initialize Docker client: {e}")\n            self.docker_client = None\n\n    async def get_public_ip(self):\n        try:\n            async with self.session.get(\'https://api.ipify.org\') as resp:\n                if resp.status == 200:\n                    return await resp.text()\n                else:\n                    logger.error(f"Failed to get public IP: {resp.status}")\n                    return \'127.0.0.1\'  # Fallback\n        except Exception as e:\n            logger.error(f"Error getting public IP: {e}")\n            return \'127.0.0.1\'\n\n    async def reconnect_containers(self):\n        """Reconnect to existing containers on startup"""\n        if not self.docker_client:\n            return\n            \n        for token, vps in list(self.db.get_all_vps().items()):\n            if vps[\'status\'] == \'running\':\n                try:\n                    container = self.docker_client.containers.get(vps[\'container_id\'])\n                    if container.status != \'running\':\n                        container.start()\n                    logger.info(f"Reconnected and started container for VPS {vps[\'vps_id\']}")\n                except docker.errors.NotFound:\n                    logger.warning(f"Container {vps[\'container_id\']} not found, removing from data")\n                    self.db.remove_vps(token)\n                except Exception as e:\n                    logger.error(f"Error reconnecting container {vps[\'vps_id\']}: {e}")\n\n    async def restore_persistent_views(self):\n        """Restore persistent views after restart"""\n        # This would be implemented to restore any persistent UI components\n        pass\n\n    async def anti_miner_monitor(self):\n        """Periodically check for mining activities"""\n        await self.wait_until_ready()\n        while not self.is_closed():\n            try:\n                for token, vps in self.db.get_all_vps().items():\n                    if vps[\'status\'] != \'running\':\n                        continue\n                    try:\n                        container = self.docker_client.containers.get(vps[\'container_id\'])\n                        if container.status != \'running\':\n                            continue\n                        \n                        # Check processes\n                        exec_result = container.exec_run("ps aux")\n                        output = exec_result.output.decode().lower()\n                        \n                        for pattern in MINER_PATTERNS:\n                            if pattern in output:\n                                logger.warning(f"Mining detected in VPS {vps[\'vps_id\']}, suspending...")\n                                container.stop()\n                                self.db.update_vps(token, {\'status\': \'suspended\'})\n                                # Notify owner\n                                try:\n                                    owner = await self.fetch_user(int(vps[\'created_by\']))\n                                    await owner.send(f"‚ö†Ô∏è Your VPS {vps[\'vps_id\']} has been suspended due to detected mining activity. Contact admin to unsuspend.")\n                                except:\n                                    pass\n                                break\n                    except Exception as e:\n                        logger.error(f"Error checking VPS {vps[\'vps_id\']} for mining: {e}")\n            except Exception as e:\n                logger.error(f"Error in anti_miner_monitor: {e}")\n            await asyncio.sleep(300)  # Check every 5 minutes\n\n    async def update_system_stats(self):\n        """Update system statistics periodically"""\n        await self.wait_until_ready()\n        while not self.is_closed():\n            try:\n                # CPU usage\n                cpu_percent = psutil.cpu_percent(interval=1)\n                \n                # Memory usage\n                mem = psutil.virtual_memory()\n                \n                # Disk usage\n                disk = psutil.disk_usage(\'/\')\n                \n                # Network IO\n                net_io = psutil.net_io_counters()\n                \n                self.system_stats = {\n                    \'cpu_usage\': cpu_percent,\n                    \'memory_usage\': mem.percent,\n                    \'memory_used\': mem.used / (1024 ** 3),  # GB\n                    \'memory_total\': mem.total / (1024 ** 3),  # GB\n                    \'disk_usage\': disk.percent,\n                    \'disk_used\': disk.used / (1024 ** 3),  # GB\n                    \'disk_total\': disk.total / (1024 ** 3),  # GB\n                    \'network_sent\': net_io.bytes_sent / (1024 ** 2),  # MB\n                    \'network_recv\': net_io.bytes_recv / (1024 ** 2),  # MB\n                    \'last_updated\': time.time()\n                }\n            except Exception as e:\n                logger.error(f"Error updating system stats: {e}")\n            await asyncio.sleep(30)\n\n    async def close(self):\n        await super().close()\n        if self.session:\n            await self.session.close()\n        if self.docker_client:\n            self.docker_client.close()\n        self.db.close()\n\ndef generate_token():\n    """Generate a random token for VPS access"""\n    return \'\'.join(random.choices(string.ascii_letters + string.digits, k=24))\n\ndef generate_vps_id():\n    """Generate a unique VPS ID"""\n    return \'\'.join(random.choices(string.ascii_uppercase + string.digits, k=10))\n\ndef get_available_port(db):\n    """Get an available random port for SSH forwarding"""\n    used_ports = db.get_used_ports()\n    while True:\n        port = random.randint(PORT_RANGE_START, PORT_RANGE_END)\n        if port not in used_ports:\n            return port\n\nasync def capture_ssh_session_line(process):\n    """Capture the SSH session line from tmate output"""\n    try:\n        while True:\n            output = await process.stdout.readline()\n            if not output:\n                break\n            output = output.decode(\'utf-8\').strip()\n            if "ssh session:" in output:\n                return output.split("ssh session:")[1].strip()\n        return None\n    except Exception as e:\n        logger.error(f"Error capturing SSH session: {e}")\n        return None\n\nasync def run_docker_command(container_id, command, timeout=120):\n    """Run a Docker command asynchronously with timeout"""\n    try:\n        process = await asyncio.create_subprocess_exec(\n            "docker", "exec", container_id, *command,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE\n        )\n        try:\n            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=timeout)\n            if process.returncode != 0:\n                raise Exception(f"Command failed: {stderr.decode()}")\n            return True, stdout.decode()\n        except asyncio.TimeoutError:\n            process.kill()\n            raise Exception(f"Command timed out after {timeout} seconds")\n    except Exception as e:\n        logger.error(f"Error running Docker command: {e}")\n        return False, str(e)\n\nasync def kill_apt_processes(container_id):\n    """Kill any running apt processes"""\n    try:\n        success, _ = await run_docker_command(container_id, ["bash", "-c", "killall apt apt-get dpkg || true"])\n        await asyncio.sleep(2)\n        success, _ = await run_docker_command(container_id, ["bash", "-c", "rm -f /var/lib/apt/lists/lock /var/cache/apt/archives/lock /var/lib/dpkg/lock*"])\n        await asyncio.sleep(2)\n        return success\n    except Exception as e:\n        logger.error(f"Error killing apt processes: {e}")\n        return False\n\nasync def wait_for_apt_lock(container_id, status_msg):\n    """Wait for apt lock to be released"""\n    max_attempts = 5\n    for attempt in range(max_attempts):\n        try:\n            await kill_apt_processes(container_id)\n            \n            process = await asyncio.create_subprocess_exec(\n                "docker", "exec", container_id, "bash", "-c", "lsof /var/lib/dpkg/lock-frontend",\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE\n            )\n            stdout, stderr = await process.communicate()\n            \n            if process.returncode != 0:\n                return True\n                \n            if isinstance(status_msg, discord.Interaction):\n                await status_msg.followup.send(f"üîÑ Waiting for package manager to be ready... (Attempt {attempt + 1}/{max_attempts})", ephemeral=True)\n            else:\n                await status_msg.edit(content=f"üîÑ Waiting for package manager to be ready... (Attempt {attempt + 1}/{max_attempts})")\n            await asyncio.sleep(5)\n        except Exception as e:\n            logger.error(f"Error checking apt lock: {e}")\n            await asyncio.sleep(5)\n    \n    return False\n\nasync def build_custom_image(vps_id, base_image=DEFAULT_OS_IMAGE):\n    """Build a custom Docker image using our template"""\n    try:\n        # Create a temporary directory for the Dockerfile\n        temp_dir = f"temp_dockerfiles/{vps_id}"\n        os.makedirs(temp_dir, exist_ok=True)\n        \n        # Generate Dockerfile content\n        dockerfile_content = DOCKERFILE_TEMPLATE.format(\n            base_image=base_image,\n            welcome_message=WELCOME_MESSAGE,\n            watermark=WATERMARK,\n            vps_id=vps_id\n        )\n        \n        # Write Dockerfile\n        dockerfile_path = os.path.join(temp_dir, "Dockerfile")\n        with open(dockerfile_path, \'w\') as f:\n            f.write(dockerfile_content)\n        \n        # Build the image\n        image_tag = f"hostforge/{vps_id.lower()}:latest"\n        build_process = await asyncio.create_subprocess_exec(\n            "docker", "build", "-t", image_tag, temp_dir,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE\n        )\n        \n        stdout, stderr = await build_process.communicate()\n        \n        if build_process.returncode != 0:\n            raise Exception(f"Failed to build image: {stderr.decode()}")\n        \n        return image_tag\n    except Exception as e:\n        logger.error(f"Error building custom image: {e}")\n        raise\n    finally:\n        # Clean up temporary directory\n        try:\n            if os.path.exists(temp_dir):\n                shutil.rmtree(temp_dir)\n        except Exception as e:\n            logger.error(f"Error cleaning up temp directory: {e}")\n\nasync def setup_container(container_id, status_msg, memory, vps_id=None, use_custom_image=False):\n    """Enhanced container setup with HostForge customization"""\n    try:\n        # Ensure container is running\n        if isinstance(status_msg, discord.Interaction):\n            await status_msg.followup.send("üîç Checking container status...", ephemeral=True)\n        else:\n            await status_msg.edit(content="üîç Checking container status...")\n            \n        container = bot.docker_client.containers.get(container_id)\n        if container.status != "running":\n            if isinstance(status_msg, discord.Interaction):\n                await status_msg.followup.send("üöÄ Starting container...", ephemeral=True)\n            else:\n                await status_msg.edit(content="üöÄ Starting container...")\n            container.start()\n            await asyncio.sleep(5)\n\n        # Install tmate and other required packages if not custom\n        if not use_custom_image:\n            if isinstance(status_msg, discord.Interaction):\n                await status_msg.followup.send("üì¶ Installing required packages...", ephemeral=True)\n            else:\n                await status_msg.edit(content="üì¶ Installing required packages...")\n                \n            # Update package list\n            success, output = await run_docker_command(container_id, ["apt-get", "update"])\n            if not success:\n                raise Exception(f"Failed to update package list: {output}")\n\n            # Install packages\n            packages = [\n                "tmate", "neofetch", "screen", "wget", "curl", "htop", "nano", "vim", \n                "openssh-server", "sudo", "ufw", "git", "docker.io", "systemd", "systemd-sysv"\n            ]\n            success, output = await run_docker_command(container_id, ["apt-get", "install", "-y"] + packages)\n            if not success:\n                raise Exception(f"Failed to install packages: {output}")\n\n        # Setup SSH\n        if isinstance(status_msg, discord.Interaction):\n            await status_msg.followup.send("üîê Configuring SSH access...", ephemeral=True)\n        else:\n            await status_msg.edit(content="üîê Configuring SSH access...")\n            \n        # For non-custom image, setup root\n        if not use_custom_image:\n            setup_commands = [\n                \'echo "root:root" | chpasswd\',\n                "sed -i \'s/#PermitRootLogin prohibit-password/PermitRootLogin yes/\' /etc/ssh/sshd_config",\n                "sed -i \'s/#PasswordAuthentication yes/PasswordAuthentication yes/\' /etc/ssh/sshd_config",\n                "service ssh restart"\n            ]\n            \n            for cmd in setup_commands:\n                success, output = await run_docker_command(container_id, ["bash", "-c", cmd])\n                if not success:\n                    raise Exception(f"Failed to setup SSH: {output}")\n\n        # Set HostForge customization\n        if isinstance(status_msg, discord.Interaction):\n            await status_msg.followup.send("üé® Setting up HostForge customization...", ephemeral=True)\n        else:\n            await status_msg.edit(content="üé® Setting up HostForge customization...")\n            \n        # Create welcome message file\n        welcome_cmd = f"echo \'{WELCOME_MESSAGE}\' > /etc/motd && echo \'echo \\"{WELCOME_MESSAGE}\\"\' >> /root/.bashrc"\n        success, output = await run_docker_command(container_id, ["bash", "-c", welcome_cmd])\n        if not success:\n            logger.warning(f"Could not set welcome message: {output}")\n\n        # Set hostname and watermark\n        if not vps_id:\n            vps_id = generate_vps_id()\n        hostname_cmd = f"echo \'hostforge-{vps_id}\' > /etc/hostname && hostname hostforge-{vps_id}"\n        success, output = await run_docker_command(container_id, ["bash", "-c", hostname_cmd])\n        if not success:\n            raise Exception(f"Failed to set hostname: {output}")\n\n        # Set memory limit in cgroup\n        if isinstance(status_msg, discord.Interaction):\n            await status_msg.followup.send("‚öôÔ∏è Setting resource limits...", ephemeral=True)\n        else:\n            await status_msg.edit(content="‚öôÔ∏è Setting resource limits...")\n            \n        memory_bytes = memory * 1024 * 1024 * 1024\n        success, output = await run_docker_command(container_id, ["bash", "-c", f"echo {memory_bytes} > /sys/fs/cgroup/memory.max"])\n        if not success:\n            logger.warning(f"Could not set memory limit in cgroup: {output}")\n\n        # Set watermark in machine info\n        success, output = await run_docker_command(container_id, ["bash", "-c", f"echo \'{WATERMARK}\' > /etc/machine-info"])\n        if not success:\n            logger.warning(f"Could not set machine info: {output}")\n\n        # Basic security setup\n        security_commands = [\n            "ufw allow ssh",\n            "ufw --force enable",\n            "apt-get -y autoremove",\n            "apt-get clean"\n        ]\n        \n        for cmd in security_commands:\n            success, output = await run_docker_command(container_id, ["bash", "-c", cmd])\n            if not success:\n                logger.warning(f"Security setup command failed: {cmd} - {output}")\n\n        if isinstance(status_msg, discord.Interaction):\n            await status_msg.followup.send("‚úÖ HostForge VPS setup completed successfully!", ephemeral=True)\n        else:\n            await status_msg.edit(content="‚úÖ HostForge VPS setup completed successfully!")\n            \n        return True, vps_id\n    except Exception as e:\n        error_msg = f"Setup failed: {str(e)}"\n        logger.error(error_msg)\n        if isinstance(status_msg, discord.Interaction):\n            await status_msg.followup.send(f"‚ùå {error_msg}", ephemeral=True)\n        else:\n            await status_msg.edit(content=f"‚ùå {error_msg}")\n        return False, None\n\nintents = discord.Intents.default()\nintents.message_content = True\nintents.members = True\nbot = HostForgeBot(command_prefix=\'/\', intents=intents, help_command=None)\n\n@bot.event\nasync def on_ready():\n    logger.info(f\'{bot.user} has connected to Discord!\')\n    \n    # Auto-start VPS containers based on status\n    if bot.docker_client:\n        for token, vps in bot.db.get_all_vps().items():\n            if vps[\'status\'] == \'running\':\n                try:\n                    container = bot.docker_client.containers.get(vps["container_id"])\n                    if container.status != "running":\n                        container.start()\n                        logger.info(f"Started container for VPS {vps[\'vps_id\']}")\n                except docker.errors.NotFound:\n                    logger.warning(f"Container {vps[\'container_id\']} not found")\n                except Exception as e:\n                    logger.error(f"Error starting container: {e}")\n    \n    try:\n        await bot.change_presence(activity=discord.Activity(type=discord.ActivityType.watching, name="HostForge VPS"))\n        synced_commands = await bot.tree.sync()\n        logger.info(f"Synced {len(synced_commands)} slash commands")\n    except Exception as e:\n        logger.error(f"Error syncing slash commands: {e}")\n\n@bot.hybrid_command(name=\'help\', description=\'Show all available commands\')\nasync def show_commands(ctx):\n    """Show all available commands"""\n    try:\n        embed = discord.Embed(title="ü§ñ HostForge VPS Bot Commands", color=discord.Color.blue())\n        \n        # User commands\n        embed.add_field(name="User Commands", value="""\n`/create_vps` - Create a new VPS (Admin only)\n`/connect_vps <token>` - Connect to your VPS\n`/list` - List all your VPS instances\n`/help` - Show this help message\n`/manage_vps <vps_id>` - Manage your VPS\n`/transfer_vps <vps_id> <user>` - Transfer VPS ownership\n`/vps_stats <vps_id>` - Show VPS resource usage\n`/change_ssh_password <vps_id>` - Change SSH password\n`/vps_shell <vps_id>` - Get shell access to your VPS\n`/vps_console <vps_id>` - Get direct console access to your VPS\n`/vps_usage` - Show your VPS usage statistics\n`/run_command <vps_id> <command>` - Run a command in your VPS\n""", inline=False)\n        \n        # Admin commands\n        if has_admin_role(ctx):\n            embed.add_field(name="Admin Commands", value="""\n`/vps_list` - List all VPS instances\n`/delete_vps <vps_id>` - Delete a VPS\n`/admin_stats` - Show system statistics\n`/cleanup_vps` - Cleanup inactive VPS instances\n`/add_admin <user>` - Add a new admin\n`/remove_admin <user>` - Remove an admin (Owner only)\n`/list_admins` - List all admin users\n`/system_info` - Show detailed system information\n`/container_limit <max>` - Set maximum container limit\n`/global_stats` - Show global usage statistics\n`/migrate_vps <vps_id>` - Migrate VPS to another host\n`/emergency_stop <vps_id>` - Force stop a problematic VPS\n`/emergency_remove <vps_id>` - Force remove a problematic VPS\n`/suspend_vps <vps_id>` - Suspend a VPS\n`/unsuspend_vps <vps_id>` - Unsuspend a VPS\n`/edit_vps <vps_id> <memory> <cpu> <disk>` - Edit VPS specifications\n`/ban_user <user>` - Ban a user from creating VPS\n`/unban_user <user>` - Unban a user\n`/list_banned` - List banned users\n`/backup_data` - Backup all data\n`/restore_data` - Restore from backup\n`/reinstall_bot` - Reinstall the bot (Owner only)\n""", inline=False)\n        \n        await ctx.send(embed=embed)\n    except Exception as e:\n        logger.error(f"Error in show_commands: {e}")\n        await ctx.send("‚ùå An error occurred while processing your request.")\n\ndef has_admin_role(ctx):\n    """Check if user has admin role or is in ADMIN_IDS"""\n    if isinstance(ctx, discord.Interaction):\n        user_id = ctx.user.id\n        roles = ctx.user.roles\n    else:\n        user_id = ctx.author.id\n        roles = ctx.author.roles\n    \n    if user_id in ADMIN_IDS:\n        return True\n    \n    return any(role.id == ADMIN_ROLE_ID for role in roles)\n\n@bot.hybrid_command(name=\'add_admin\', description=\'Add a new admin (Admin only)\')\n@app_commands.describe(\n    user="User to make admin"\n)\nasync def add_admin(ctx, user: discord.User):\n    """Add a new admin user"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n    \n    bot.db.add_admin(user.id)\n    await ctx.send(f"‚úÖ {user.mention} has been added as an admin!", ephemeral=True)\n\n@bot.hybrid_command(name=\'remove_admin\', description=\'Remove an admin (Owner only)\')\n@app_commands.describe(\n    user="User to remove from admin"\n)\nasync def remove_admin(ctx, user: discord.User):\n    """Remove an admin user (Owner only)"""\n    if ctx.author.id != 1210291131301101618:  # Only the owner can remove admins\n        await ctx.send("‚ùå Only the owner can remove admins!", ephemeral=True)\n        return\n    \n    bot.db.remove_admin(user.id)\n    await ctx.send(f"‚úÖ {user.mention} has been removed from admins!", ephemeral=True)\n\n@bot.hybrid_command(name=\'list_admins\', description=\'List all admin users\')\nasync def list_admins(ctx):\n    """List all admin users"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n    \n    embed = discord.Embed(title="Admin Users", color=discord.Color.blue())\n    \n    # List user IDs in ADMIN_IDS\n    admin_list = []\n    for admin_id in ADMIN_IDS:\n        try:\n            user = await bot.fetch_user(admin_id)\n            admin_list.append(f"{user.name} ({user.id})")\n        except:\n            admin_list.append(f"Unknown User ({admin_id})")\n    \n    # List users with admin role\n    if ctx.guild:\n        admin_role = ctx.guild.get_role(ADMIN_ROLE_ID)\n        if admin_role:\n            role_admins = [f"{member.name} ({member.id})" for member in admin_role.members]\n            admin_list.extend(role_admins)\n    \n    if not admin_list:\n        embed.description = "No admins found"\n    else:\n        embed.description = "\\n".join(sorted(set(admin_list)))  # Remove duplicates\n    \n    await ctx.send(embed=embed, ephemeral=True)\n\n@bot.hybrid_command(name=\'create_vps\', description=\'Create a new VPS (Admin only)\')\n@app_commands.describe(\n    memory="Memory in GB",\n    cpu="CPU cores",\n    disk="Disk space in GB",\n    owner="User who will own the VPS",\n    os_image="OS image to use",\n    use_custom_image="Use custom HostForge image (recommended)"\n)\nasync def create_vps_command(ctx, memory: int, cpu: int, disk: int, owner: discord.Member, \n                           os_image: str = DEFAULT_OS_IMAGE, use_custom_image: bool = True):\n    """Create a new VPS with specified parameters (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    if bot.db.is_user_banned(owner.id):\n        await ctx.send("‚ùå This user is banned from creating VPS!", ephemeral=True)\n        return\n\n    if not ctx.guild:\n        await ctx.send("‚ùå This command can only be used in a server!", ephemeral=True)\n        return\n\n    if not bot.docker_client:\n        await ctx.send("‚ùå Docker is not available. Please contact the administrator.", ephemeral=True)\n        return\n\n    try:\n        # Validate inputs\n        if memory < 1 or memory > 512:\n            await ctx.send("‚ùå Memory must be between 1GB and 512GB", ephemeral=True)\n            return\n        if cpu < 1 or cpu > 32:\n            await ctx.send("‚ùå CPU cores must be between 1 and 32", ephemeral=True)\n            return\n        if disk < 10 or disk > 1000:\n            await ctx.send("‚ùå Disk space must be between 10GB and 1000GB", ephemeral=True)\n            return\n\n        # Check if we\'ve reached container limit\n        containers = bot.docker_client.containers.list(all=True)\n        if len(containers) >= bot.db.get_setting(\'max_containers\', MAX_CONTAINERS):\n            await ctx.send(f"‚ùå Maximum container limit reached ({bot.db.get_setting(\'max_containers\')}). Please delete some VPS instances first.", ephemeral=True)\n            return\n\n        # Check if user already has maximum VPS instances\n        if bot.db.get_user_vps_count(owner.id) >= bot.db.get_setting(\'max_vps_per_user\', MAX_VPS_PER_USER):\n            await ctx.send(f"‚ùå {owner.mention} already has the maximum number of VPS instances ({bot.db.get_setting(\'max_vps_per_user\')})", ephemeral=True)\n            return\n\n        status_msg = await ctx.send("üöÄ Creating HostForge VPS instance... This may take a few minutes.")\n\n        memory_bytes = memory * 1024 * 1024 * 1024\n        vps_id = generate_vps_id()\n        username = "root"\n        password = "root"\n        token = generate_token()\n        external_port = get_available_port(bot.db)\n\n        if use_custom_image:\n            await status_msg.edit(content="üî® Building custom Docker image...")\n            try:\n                image_tag = await build_custom_image(vps_id, os_image)\n            except Exception as e:\n                await status_msg.edit(content=f"‚ùå Failed to build Docker image: {str(e)}")\n                return\n\n            await status_msg.edit(content="‚öôÔ∏è Initializing container...")\n            try:\n                container = bot.docker_client.containers.run(\n                    image_tag,\n                    detach=True,\n                    privileged=True,\n                    hostname=f"hostforge-{vps_id}",\n                    mem_limit=memory_bytes,\n                    cpu_period=100000,\n                    cpu_quota=int(cpu * 100000),\n                    cap_add=["ALL"],\n                    network=DOCKER_NETWORK,\n                    ports={\'22/tcp\': str(external_port)},\n                    volumes={\n                        f\'hostforge-{vps_id}\': {\'bind\': \'/data\', \'mode\': \'rw\'}\n                    },\n                    restart_policy={"Name": "always"}\n                )\n            except Exception as e:\n                await status_msg.edit(content=f"‚ùå Failed to start container: {str(e)}")\n                return\n        else:\n            await status_msg.edit(content="‚öôÔ∏è Initializing container...")\n            try:\n                container = bot.docker_client.containers.run(\n                    os_image,\n                    detach=True,\n                    privileged=True,\n                    hostname=f"hostforge-{vps_id}",\n                    mem_limit=memory_bytes,\n                    cpu_period=100000,\n                    cpu_quota=int(cpu * 100000),\n                    cap_add=["ALL"],\n                    command="tail -f /dev/null",\n                    tty=True,\n                    network=DOCKER_NETWORK,\n                    ports={\'22/tcp\': str(external_port)},\n                    volumes={\n                        f\'hostforge-{vps_id}\': {\'bind\': \'/data\', \'mode\': \'rw\'}\n                    },\n                    restart_policy={"Name": "always"}\n                )\n            except docker.errors.ImageNotFound:\n                await status_msg.edit(content=f"‚ùå OS image {os_image} not found. Using default {DEFAULT_OS_IMAGE}")\n                container = bot.docker_client.containers.run(\n                    DEFAULT_OS_IMAGE,\n                    detach=True,\n                    privileged=True,\n                    hostname=f"hostforge-{vps_id}",\n                    mem_limit=memory_bytes,\n                    cpu_period=100000,\n                    cpu_quota=int(cpu * 100000),\n                    cap_add=["ALL"],\n                    command="tail -f /dev/null",\n                    tty=True,\n                    network=DOCKER_NETWORK,\n                    ports={\'22/tcp\': str(external_port)},\n                    volumes={\n                        f\'hostforge-{vps_id}\': {\'bind\': \'/data\', \'mode\': \'rw\'}\n                    },\n                    restart_policy={"Name": "always"}\n                )\n                os_image = DEFAULT_OS_IMAGE\n\n        await status_msg.edit(content="üîß Container created. Setting up HostForge environment...")\n        await asyncio.sleep(5)\n\n        setup_success, _ = await setup_container(\n            container.id, \n            status_msg, \n            memory, \n            vps_id=vps_id,\n            use_custom_image=use_custom_image\n        )\n        if not setup_success:\n            raise Exception("Failed to setup container")\n\n        await status_msg.edit(content="üîê Starting SSH session...")\n\n        exec_cmd = await asyncio.create_subprocess_exec(\n            "docker", "exec", container.id, "tmate", "-F",\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE\n        )\n\n        ssh_session_line = await capture_ssh_session_line(exec_cmd)\n        if not ssh_session_line:\n            raise Exception("Failed to get tmate session")\n        \n        vps_data = {\n            "token": token,\n            "vps_id": vps_id,\n            "container_id": container.id,\n            "memory": memory,\n            "cpu": cpu,\n            "disk": disk,\n            "username": username,\n            "password": password,\n            "root_password": "root",\n            "created_by": str(owner.id),\n            "created_at": str(datetime.datetime.now()),\n            "tmate_session": ssh_session_line,\n            "watermark": WATERMARK,\n            "os_image": os_image,\n            "restart_count": 0,\n            "last_restart": None,\n            "status": "running",\n            "use_custom_image": use_custom_image,\n            "external_ssh_port": external_port\n        }\n        \n        bot.db.add_vps(vps_data)\n        \n        try:\n            embed = discord.Embed(title="üéâ HostForge VPS Creation Successful", color=discord.Color.green())\n            embed.add_field(name="üÜî VPS ID", value=vps_id, inline=True)\n            embed.add_field(name="üíæ Memory", value=f"{memory}GB", inline=True)\n            embed.add_field(name="‚ö° CPU", value=f"{cpu} cores", inline=True)\n            embed.add_field(name="üíø Disk", value=f"{disk}GB", inline=True)\n            embed.add_field(name="üë§ Username", value=username, inline=True)\n            embed.add_field(name="üîë Password", value=f"||{password}||", inline=False)\n            embed.add_field(name="üîí Tmate Session", value=f"```{ssh_session_line}```", inline=False)\n            embed.add_field(name="üîå Direct SSH", value=f"```ssh root@{bot.public_ip} -p {external_port}```", inline=False)\n            embed.add_field(name="‚ÑπÔ∏è Note", value="This is a HostForge VPS instance. You can install and configure additional packages as needed.", inline=False)\n            \n            await owner.send(embed=embed)\n            await status_msg.edit(content=f"‚úÖ HostForge VPS creation successful! VPS has been created for {owner.mention}. Check your DMs for connection details.")\n        except discord.Forbidden:\n            await status_msg.edit(content=f"‚ùå I couldn\'t send a DM to {owner.mention}. Please ask them to enable DMs from server members.")\n            \n    except Exception as e:\n        error_msg = f"‚ùå An error occurred while creating the VPS: {str(e)}"\n        logger.error(error_msg)\n        await ctx.send(error_msg)\n        if \'container\' in locals():\n            try:\n                container.stop()\n                container.remove()\n            except Exception as e:\n                logger.error(f"Error cleaning up container: {e}")\n\n@bot.hybrid_command(name=\'list\', description=\'List all your VPS instances\')\nasync def list_vps(ctx):\n    """List all VPS instances owned by the user"""\n    try:\n        user_vps = bot.db.get_user_vps(ctx.author.id)\n        \n        if not user_vps:\n            await ctx.send("You don\'t have any VPS instances.", ephemeral=True)\n            return\n\n        embed = discord.Embed(title="Your HostForge VPS Instances", color=discord.Color.blue())\n        \n        for vps in user_vps:\n            try:\n                # Handle missing container ID gracefully\n                container = bot.docker_client.containers.get(vps["container_id"]) if vps["container_id"] else None\n                status = vps[\'status\'].capitalize() if vps.get(\'status\') else "Unknown"\n            except Exception as e:\n                status = "Not Found"\n                logger.error(f"Error fetching container {vps[\'container_id\']}: {e}")\n\n            # Adding fields safely to prevent missing keys causing errors\n            embed.add_field(\n                name=f"VPS {vps[\'vps_id\']}",\n                value=f"""\nStatus: {status}\nMemory: {vps.get(\'memory\', \'Unknown\')}GB\nCPU: {vps.get(\'cpu\', \'Unknown\')} cores\nDisk Allocated: {vps.get(\'disk\', \'Unknown\')}GB\nUsername: {vps.get(\'username\', \'Unknown\')}\nOS: {vps.get(\'os_image\', DEFAULT_OS_IMAGE)}\nCreated: {vps.get(\'created_at\', \'Unknown\')}\nRestarts: {vps.get(\'restart_count\', 0)}\nSSH Port: {vps.get(\'external_ssh_port\', \'Not set\')}\n""",\n                inline=False\n            )\n        \n        await ctx.send(embed=embed)\n    except Exception as e:\n        logger.error(f"Error in list_vps: {e}")\n        await ctx.send(f"‚ùå Error listing VPS instances: {str(e)}")\n\n@bot.hybrid_command(name=\'vps_list\', description=\'List all VPS instances (Admin only)\')\nasync def admin_list_vps(ctx):\n    """List all VPS instances (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    try:\n        all_vps = bot.db.get_all_vps()\n        if not all_vps:\n            await ctx.send("No VPS instances found.", ephemeral=True)\n            return\n\n        embed = discord.Embed(title="All HostForge VPS Instances", color=discord.Color.blue())\n        valid_vps_count = 0\n        \n        for token, vps in all_vps.items():\n            try:\n                # Fetch username of the owner with error handling\n                user = await bot.fetch_user(int(vps.get("created_by", "0")))\n                username = user.name if user else "Unknown User"\n            except Exception as e:\n                username = "Unknown User"\n                logger.error(f"Error fetching user {vps.get(\'created_by\')}: {e}")\n\n            try:\n                # Handle missing container ID gracefully\n                container = bot.docker_client.containers.get(vps.get("container_id", "")) if vps.get("container_id") else None\n                container_status = container.status if container else "Not Found"\n            except Exception as e:\n                container_status = "Not Found"\n                logger.error(f"Error fetching container {vps.get(\'container_id\')}: {e}")\n\n            # Get status and other info with error fallback\n            status = vps.get(\'status\', "Unknown").capitalize()\n\n            vps_info = f"""\nOwner: {username}\nStatus: {status} (Container: {container_status})\nMemory: {vps.get(\'memory\', \'Unknown\')}GB\nCPU: {vps.get(\'cpu\', \'Unknown\')} cores\nDisk: {vps.get(\'disk\', \'Unknown\')}GB\nUsername: {vps.get(\'username\', \'Unknown\')}\nOS: {vps.get(\'os_image\', DEFAULT_OS_IMAGE)}\nCreated: {vps.get(\'created_at\', \'Unknown\')}\nRestarts: {vps.get(\'restart_count\', 0)}\nSSH Port: {vps.get(\'external_ssh_port\', \'Not set\')}\n"""\n\n            embed.add_field(\n                name=f"VPS {vps.get(\'vps_id\', \'Unknown\')}",\n                value=vps_info,\n                inline=False\n            )\n            valid_vps_count += 1\n\n        if valid_vps_count == 0:\n            await ctx.send("No valid VPS instances found.", ephemeral=True)\n            return\n\n        embed.set_footer(text=f"Total VPS instances: {valid_vps_count}")\n        await ctx.send(embed=embed)\n    except Exception as e:\n        logger.error(f"Error in admin_list_vps: {e}")\n        await ctx.send(f"‚ùå Error listing VPS instances: {str(e)}")\n\n@bot.hybrid_command(name=\'delete_vps\', description=\'Delete a VPS instance (Admin only)\')\n@app_commands.describe(\n    vps_id="ID of the VPS to delete"\n)\nasync def delete_vps(ctx, vps_id: str):\n    """Delete a VPS instance (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    try:\n        token, vps = bot.db.get_vps_by_id(vps_id)\n        if not vps:\n            await ctx.send("‚ùå VPS not found!", ephemeral=True)\n            return\n        \n        try:\n            container = bot.docker_client.containers.get(vps["container_id"])\n            container.stop()\n            container.remove()\n            logger.info(f"Deleted container {vps[\'container_id\']} for VPS {vps_id}")\n        except Exception as e:\n            logger.error(f"Error removing container: {e}")\n        \n        bot.db.remove_vps(token)\n        \n        await ctx.send(f"‚úÖ HostForge VPS {vps_id} has been deleted successfully!")\n    except Exception as e:\n        logger.error(f"Error in delete_vps: {e}")\n        await ctx.send(f"‚ùå Error deleting VPS: {str(e)}")\n\n@bot.hybrid_command(name=\'connect_vps\', description=\'Connect to a VPS using the provided token\')\n@app_commands.describe(\n    token="Access token for the VPS"\n)\nasync def connect_vps(ctx, token: str):\n    """Connect to a VPS using the provided token"""\n    vps = bot.db.get_vps_by_token(token)\n    if not vps:\n        await ctx.send("‚ùå Invalid token!", ephemeral=True)\n        return\n        \n    if str(ctx.author.id) != vps["created_by"] and not has_admin_role(ctx):\n        await ctx.send("‚ùå You don\'t have permission to access this VPS!", ephemeral=True)\n        return\n\n    try:\n        try:\n            container = bot.docker_client.containers.get(vps["container_id"])\n            if container.status != "running":\n                container.start()\n                await asyncio.sleep(5)\n        except:\n            await ctx.send("‚ùå VPS instance not found or is no longer available.", ephemeral=True)\n            return\n\n        exec_cmd = await asyncio.create_subprocess_exec(\n            "docker", "exec", vps["container_id"], "tmate", "-F",\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE\n        )\n\n        ssh_session_line = await capture_ssh_session_line(exec_cmd)\n        if not ssh_session_line:\n            raise Exception("Failed to get tmate session")\n\n        bot.db.update_vps(token, {"tmate_session": ssh_session_line})\n        \n        embed = discord.Embed(title="HostForge VPS Connection Details", color=discord.Color.blue())\n        embed.add_field(name="Username", value=vps["username"], inline=True)\n        embed.add_field(name="SSH Password", value=f"||{vps.get(\'password\', \'Not set\')}||", inline=True)\n        embed.add_field(name="Tmate Session", value=f"```{ssh_session_line}```", inline=False)\n        embed.add_field(name="Direct SSH", value=f"```ssh root@{bot.public_ip} -p {vps[\'external_ssh_port\']}```", inline=False)\n        embed.add_field(name="Connection Instructions", value="""\n1. Copy the Tmate session command\n2. Open your terminal\n3. Paste and run the command\n4. You will be connected to your HostForge VPS\n\nOr use direct SSH with the provided command.\n""", inline=False)\n        \n        await ctx.author.send(embed=embed)\n        await ctx.send("‚úÖ Connection details sent to your DMs! Use the Tmate command to connect to your HostForge VPS.", ephemeral=True)\n        \n    except discord.Forbidden:\n        await ctx.send("‚ùå I couldn\'t send you a DM. Please enable DMs from server members.", ephemeral=True)\n    except Exception as e:\n        logger.error(f"Error in connect_vps: {e}")\n        await ctx.send(f"‚ùå An error occurred while connecting to the VPS: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'vps_stats\', description=\'Show resource usage for a VPS\')\n@app_commands.describe(\n    vps_id="ID of the VPS to check"\n)\nasync def vps_stats(ctx, vps_id: str):\n    """Show resource usage for a VPS"""\n    try:\n        token, vps = bot.db.get_vps_by_id(vps_id)\n        if not vps or (vps["created_by"] != str(ctx.author.id) and not has_admin_role(ctx)):\n            await ctx.send("‚ùå VPS not found or you don\'t have access to it!", ephemeral=True)\n            return\n\n        try:\n            container = bot.docker_client.containers.get(vps["container_id"])\n            if container.status != "running":\n                await ctx.send("‚ùå VPS is not running!", ephemeral=True)\n                return\n\n            # Get memory stats\n            mem_process = await asyncio.create_subprocess_exec(\n                "docker", "exec", vps["container_id"], "free", "-m",\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE\n            )\n            stdout, stderr = await mem_process.communicate()\n            \n            if mem_process.returncode != 0:\n                raise Exception(f"Failed to get memory info: {stderr.decode()}")\n\n            # Get CPU stats\n            cpu_process = await asyncio.create_subprocess_exec(\n                "docker", "exec", vps["container_id"], "top", "-bn1",\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE\n            )\n            cpu_stdout, cpu_stderr = await cpu_process.communicate()\n\n            # Get disk stats\n            disk_process = await asyncio.create_subprocess_exec(\n                "docker", "exec", vps["container_id"], "df", "-h",\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE\n            )\n            disk_stdout, disk_stderr = await disk_process.communicate()\n\n            embed = discord.Embed(title=f"Resource Usage for VPS {vps_id}", color=discord.Color.blue())\n            embed.add_field(name="Memory Info", value=f"```{stdout.decode()}```", inline=False)\n            \n            if disk_process.returncode == 0:\n                embed.add_field(name="Disk Info", value=f"```{disk_stdout.decode()}```", inline=False)\n            \n            embed.add_field(name="Configured Limits", value=f"""\nMemory: {vps[\'memory\']}GB\nCPU: {vps[\'cpu\']} cores\nDisk Allocated: {vps[\'disk\']}GB\nSSH Port: {vps[\'external_ssh_port\']}\n""", inline=True)\n            \n            await ctx.send(embed=embed)\n        except Exception as e:\n            await ctx.send(f"‚ùå Error checking VPS stats: {str(e)}", ephemeral=True)\n    except Exception as e:\n        logger.error(f"Error in vps_stats: {e}")\n        await ctx.send(f"‚ùå Error: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'change_ssh_password\', description=\'Change the SSH password for a VPS\')\n@app_commands.describe(\n    vps_id="ID of the VPS to update"\n)\nasync def change_ssh_password(ctx, vps_id: str):\n    """Change the SSH password for a VPS"""\n    try:\n        token, vps = bot.db.get_vps_by_id(vps_id)\n        if not vps or vps["created_by"] != str(ctx.author.id):\n            await ctx.send("‚ùå VPS not found or you don\'t have access to it!", ephemeral=True)\n            return\n\n        try:\n            container = bot.docker_client.containers.get(vps["container_id"])\n            if container.status != "running":\n                await ctx.send("‚ùå VPS is not running!", ephemeral=True)\n                return\n\n            new_password = generate_ssh_password()\n            \n            process = await asyncio.create_subprocess_exec(\n                "docker", "exec", vps["container_id"], "bash", "-c", f"echo \'root:{new_password}\' | chpasswd",\n                stdout=asyncio.subprocess.PIPE,\n                stderr=asyncio.subprocess.PIPE\n            )\n            stdout, stderr = await process.communicate()\n            \n            if process.returncode != 0:\n                raise Exception(f"Failed to change password: {stderr.decode()}")\n\n            bot.db.update_vps(token, {\'password\': new_password})\n            \n            embed = discord.Embed(title=f"SSH Password Updated for VPS {vps_id}", color=discord.Color.green())\n            embed.add_field(name="Username", value="root", inline=True)\n            embed.add_field(name="New Password", value=f"||{new_password}||", inline=False)\n            embed.add_field(name="Direct SSH", value=f"```ssh root@{bot.public_ip} -p {vps[\'external_ssh_port\']}```", inline=False)\n            \n            await ctx.author.send(embed=embed)\n            await ctx.send("‚úÖ SSH password updated successfully! Check your DMs for the new password.", ephemeral=True)\n        except Exception as e:\n            await ctx.send(f"‚ùå Error changing SSH password: {str(e)}", ephemeral=True)\n    except Exception as e:\n        logger.error(f"Error in change_ssh_password: {e}")\n        await ctx.send(f"‚ùå Error: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'admin_stats\', description=\'Show system statistics (Admin only)\')\nasync def admin_stats(ctx):\n    """Show system statistics (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    try:\n        # Get Docker stats\n        containers = bot.docker_client.containers.list(all=True) if bot.docker_client else []\n        \n        # Get system stats\n        stats = bot.system_stats\n        \n        embed = discord.Embed(title="HostForge System Statistics", color=discord.Color.blue())\n        embed.add_field(name="VPS Instances", value=f"Total: {len(bot.db.get_all_vps())}\\nRunning: {len([c for c in containers if c.status == \'running\'])}", inline=True)\n        embed.add_field(name="Docker Containers", value=f"Total: {len(containers)}\\nRunning: {len([c for c in containers if c.status == \'running\'])}", inline=True)\n        embed.add_field(name="CPU Usage", value=f"{stats[\'cpu_usage\']}%", inline=True)\n        embed.add_field(name="Memory Usage", value=f"{stats[\'memory_usage\']}% ({stats[\'memory_used\']:.2f}GB / {stats[\'memory_total\']:.2f}GB)", inline=True)\n        embed.add_field(name="Disk Usage", value=f"{stats[\'disk_usage\']}% ({stats[\'disk_used\']:.2f}GB / {stats[\'disk_total\']:.2f}GB)", inline=True)\n        embed.add_field(name="Network", value=f"Sent: {stats[\'network_sent\']:.2f}MB\\nRecv: {stats[\'network_recv\']:.2f}MB", inline=True)\n        embed.add_field(name="Container Limit", value=f"{len(containers)}/{bot.db.get_setting(\'max_containers\')}", inline=True)\n        embed.add_field(name="Last Updated", value=f"<t:{int(stats[\'last_updated\'])}:R>", inline=True)\n        \n        await ctx.send(embed=embed)\n    except Exception as e:\n        logger.error(f"Error in admin_stats: {e}")\n        await ctx.send(f"‚ùå Error getting system stats: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'system_info\', description=\'Show detailed system information (Admin only)\')\nasync def system_info(ctx):\n    """Show detailed system information (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    try:\n        # System information\n        uname = platform.uname()\n        boot_time = datetime.datetime.fromtimestamp(psutil.boot_time())\n        \n        # CPU information\n        cpu_info = f"""\nSystem: {uname.system}\nNode Name: {uname.node}\nRelease: {uname.release}\nVersion: {uname.version}\nMachine: {uname.machine}\nProcessor: {uname.processor}\nPhysical cores: {psutil.cpu_count(logical=False)}\nTotal cores: {psutil.cpu_count(logical=True)}\nCPU Usage: {psutil.cpu_percent()}%\n"""\n        \n        # Memory Information\n        svmem = psutil.virtual_memory()\n        mem_info = f"""\nTotal: {svmem.total / (1024**3):.2f}GB\nAvailable: {svmem.available / (1024**3):.2f}GB\nUsed: {svmem.used / (1024**3):.2f}GB\nPercentage: {svmem.percent}%\n"""\n        \n        # Disk Information\n        partitions = psutil.disk_partitions()\n        disk_info = ""\n        for partition in partitions:\n            try:\n                partition_usage = psutil.disk_usage(partition.mountpoint)\n                disk_info += f"""\nDevice: {partition.device}\n  Mountpoint: {partition.mountpoint}\n  File system type: {partition.fstype}\n  Total Size: {partition_usage.total / (1024**3):.2f}GB\n  Used: {partition_usage.used / (1024**3):.2f}GB\n  Free: {partition_usage.free / (1024**3):.2f}GB\n  Percentage: {partition_usage.percent}%\n"""\n            except PermissionError:\n                continue\n        \n        # Network information\n        net_io = psutil.net_io_counters()\n        net_info = f"""\nBytes Sent: {net_io.bytes_sent / (1024**2):.2f}MB\nBytes Received: {net_io.bytes_recv / (1024**2):.2f}MB\n"""\n        \n        embed = discord.Embed(title="Detailed System Information", color=discord.Color.blue())\n        embed.add_field(name="System", value=f"Boot Time: {boot_time}", inline=False)\n        embed.add_field(name="CPU Info", value=f"```{cpu_info}```", inline=False)\n        embed.add_field(name="Memory Info", value=f"```{mem_info}```", inline=False)\n        embed.add_field(name="Disk Info", value=f"```{disk_info}```", inline=False)\n        embed.add_field(name="Network Info", value=f"```{net_info}```", inline=False)\n        \n        await ctx.send(embed=embed)\n    except Exception as e:\n        logger.error(f"Error in system_info: {e}")\n        await ctx.send(f"‚ùå Error getting system info: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'container_limit\', description=\'Set maximum container limit (Owner only)\')\n@app_commands.describe(\n    max_limit="New maximum container limit"\n)\nasync def set_container_limit(ctx, max_limit: int):\n    """Set maximum container limit (Owner only)"""\n    if ctx.author.id != 1210291131301101618:  # Only the owner can set limit\n        await ctx.send("‚ùå Only the owner can set container limit!", ephemeral=True)\n        return\n    \n    if max_limit < 1 or max_limit > 1000:\n        await ctx.send("‚ùå Container limit must be between 1 and 1000", ephemeral=True)\n        return\n    \n    bot.db.set_setting(\'max_containers\', max_limit)\n    await ctx.send(f"‚úÖ Maximum container limit set to {max_limit}", ephemeral=True)\n\n@bot.hybrid_command(name=\'cleanup_vps\', description=\'Cleanup inactive VPS instances (Admin only)\')\nasync def cleanup_vps(ctx):\n    """Cleanup inactive VPS instances (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    try:\n        cleanup_count = 0\n        \n        for token, vps in list(bot.db.get_all_vps().items()):\n            try:\n                container = bot.docker_client.containers.get(vps[\'container_id\'])\n                if container.status != \'running\':\n                    container.stop()\n                    container.remove()\n                    bot.db.remove_vps(token)\n                    cleanup_count += 1\n            except docker.errors.NotFound:\n                bot.db.remove_vps(token)\n                cleanup_count += 1\n            except Exception as e:\n                logger.error(f"Error cleaning up VPS {vps[\'vps_id\']}: {e}")\n                continue\n        \n        if cleanup_count > 0:\n            await ctx.send(f"‚úÖ Cleaned up {cleanup_count} inactive VPS instances!")\n        else:\n            await ctx.send("‚ÑπÔ∏è No inactive VPS instances found to clean up.")\n    except Exception as e:\n        logger.error(f"Error in cleanup_vps: {e}")\n        await ctx.send(f"‚ùå Error during cleanup: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'vps_shell\', description=\'Get shell access to your VPS\')\n@app_commands.describe(\n    vps_id="ID of the VPS to access"\n)\nasync def vps_shell(ctx, vps_id: str):\n    """Get shell access to your VPS"""\n    try:\n        token, vps = bot.db.get_vps_by_id(vps_id)\n        if not vps or (vps["created_by"] != str(ctx.author.id) and not has_admin_role(ctx)):\n            await ctx.send("‚ùå VPS not found or you don\'t have access to it!", ephemeral=True)\n            return\n\n        try:\n            container = bot.docker_client.containers.get(vps["container_id"])\n            if container.status != "running":\n                await ctx.send("‚ùå VPS is not running!", ephemeral=True)\n                return\n\n            await ctx.send(f"‚úÖ Shell access to VPS {vps_id}:\\n"\n                          f"```docker exec -it {vps[\'container_id\']} bash```\\n"\n                          f"Username: root\\n"\n                          f"Password: ||{vps.get(\'password\', \'Not set\')}||", ephemeral=True)\n        except Exception as e:\n            await ctx.send(f"‚ùå Error accessing VPS shell: {str(e)}", ephemeral=True)\n    except Exception as e:\n        logger.error(f"Error in vps_shell: {e}")\n        await ctx.send(f"‚ùå Error: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'vps_console\', description=\'Get direct console access to your VPS\')\n@app_commands.describe(\n    vps_id="ID of the VPS to access"\n)\nasync def vps_console(ctx, vps_id: str):\n    """Get direct console access to your VPS"""\n    try:\n        token, vps = bot.db.get_vps_by_id(vps_id)\n        if not vps or (vps["created_by"] != str(ctx.author.id) and not has_admin_role(ctx)):\n            await ctx.send("‚ùå VPS not found or you don\'t have access to it!", ephemeral=True)\n            return\n\n        try:\n            container = bot.docker_client.containers.get(vps["container_id"])\n            if container.status != "running":\n                await ctx.send("‚ùå VPS is not running!", ephemeral=True)\n                return\n\n            await ctx.send(f"‚úÖ Console access to VPS {vps_id}:\\n"\n                          f"```docker attach {vps[\'container_id\']}```\\n"\n                          f"Note: To detach from the console without stopping the container, use Ctrl+P followed by Ctrl+Q", \n                          ephemeral=True)\n        except Exception as e:\n            await ctx.send(f"‚ùå Error accessing VPS console: {str(e)}", ephemeral=True)\n    except Exception as e:\n        logger.error(f"Error in vps_console: {e}")\n        await ctx.send(f"‚ùå Error: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'run_command\', description=\'Run a command in your VPS\')\n@app_commands.describe(\n    vps_id="ID of the VPS",\n    command="Command to run"\n)\nasync def run_command(ctx, vps_id: str, command: str):\n    """Run a command in your VPS"""\n    try:\n        token, vps = bot.db.get_vps_by_id(vps_id)\n        if not vps or (vps["created_by"] != str(ctx.author.id) and not has_admin_role(ctx)):\n            await ctx.send("‚ùå VPS not found or you don\'t have access to it!", ephemeral=True)\n            return\n\n        try:\n            container = bot.docker_client.containers.get(vps["container_id"])\n            if container.status != "running":\n                await ctx.send("‚ùå VPS is not running!", ephemeral=True)\n                return\n\n            success, output = await run_docker_command(vps["container_id"], ["bash", "-c", command])\n            if success:\n                await ctx.send(f"‚úÖ Command executed successfully:\\n```{output}```", ephemeral=True)\n            else:\n                await ctx.send(f"‚ùå Command failed:\\n```{output}```", ephemeral=True)\n        except Exception as e:\n            await ctx.send(f"‚ùå Error running command: {str(e)}", ephemeral=True)\n    except Exception as e:\n        logger.error(f"Error in run_command: {e}")\n        await ctx.send(f"‚ùå Error: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'vps_usage\', description=\'Show your VPS usage statistics\')\nasync def vps_usage(ctx):\n    """Show your VPS usage statistics"""\n    try:\n        user_vps = bot.db.get_user_vps(ctx.author.id)\n        \n        total_memory = sum(vps[\'memory\'] for vps in user_vps)\n        total_cpu = sum(vps[\'cpu\'] for vps in user_vps)\n        total_disk = sum(vps[\'disk\'] for vps in user_vps)\n        total_restarts = sum(vps.get(\'restart_count\', 0) for vps in user_vps)\n        \n        embed = discord.Embed(title="Your HostForge VPS Usage", color=discord.Color.blue())\n        embed.add_field(name="Total VPS Instances", value=len(user_vps), inline=True)\n        embed.add_field(name="Total Memory Allocated", value=f"{total_memory}GB", inline=True)\n        embed.add_field(name="Total CPU Cores Allocated", value=total_cpu, inline=True)\n        embed.add_field(name="Total Disk Allocated", value=f"{total_disk}GB", inline=True)\n        embed.add_field(name="Total Restarts", value=total_restarts, inline=True)\n        \n        await ctx.send(embed=embed)\n    except Exception as e:\n        logger.error(f"Error in vps_usage: {e}")\n        await ctx.send(f"‚ùå Error: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'global_stats\', description=\'Show global usage statistics (Admin only)\')\nasync def global_stats(ctx):\n    """Show global usage statistics (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    try:\n        all_vps = bot.db.get_all_vps()\n        total_memory = sum(vps[\'memory\'] for vps in all_vps.values())\n        total_cpu = sum(vps[\'cpu\'] for vps in all_vps.values())\n        total_disk = sum(vps[\'disk\'] for vps in all_vps.values())\n        total_restarts = sum(vps.get(\'restart_count\', 0) for vps in all_vps.values())\n        \n        embed = discord.Embed(title="HostForge Global Usage Statistics", color=discord.Color.blue())\n        embed.add_field(name="Total VPS Created", value=bot.db.get_stat(\'total_vps_created\'), inline=True)\n        embed.add_field(name="Total Restarts", value=bot.db.get_stat(\'total_restarts\'), inline=True)\n        embed.add_field(name="Current VPS Instances", value=len(all_vps), inline=True)\n        embed.add_field(name="Total Memory Allocated", value=f"{total_memory}GB", inline=True)\n        embed.add_field(name="Total CPU Cores Allocated", value=total_cpu, inline=True)\n        embed.add_field(name="Total Disk Allocated", value=f"{total_disk}GB", inline=True)\n        embed.add_field(name="Total Restarts", value=total_restarts, inline=True)\n        \n        await ctx.send(embed=embed)\n    except Exception as e:\n        logger.error(f"Error in global_stats: {e}")\n        await ctx.send(f"‚ùå Error: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'migrate_vps\', description=\'Migrate a VPS to another host (Admin only)\')\n@app_commands.describe(\n    vps_id="ID of the VPS to migrate"\n)\nasync def migrate_vps(ctx, vps_id: str):\n    """Migrate a VPS to another host (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    try:\n        token, vps = bot.db.get_vps_by_id(vps_id)\n        if not vps:\n            await ctx.send("‚ùå VPS not found!", ephemeral=True)\n            return\n\n        status_msg = await ctx.send(f"üîÑ Preparing to migrate VPS {vps_id}...")\n        \n        # Create a snapshot\n        backup_id = generate_vps_id()[:8]\n        backup_time = datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\')\n        backup_dir = f"migrations/{vps_id}"\n        os.makedirs(backup_dir, exist_ok=True)\n        backup_file = f"{backup_dir}/{backup_id}.tar"\n        \n        await status_msg.edit(content=f"üîÑ Creating snapshot {backup_id} for migration...")\n        \n        process = await asyncio.create_subprocess_exec(\n            "docker", "export", "-o", backup_file, vps["container_id"],\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE\n        )\n        stdout, stderr = await process.communicate()\n        \n        if process.returncode != 0:\n            raise Exception(f"Snapshot failed: {stderr.decode()}")\n        \n        await status_msg.edit(content=f"‚úÖ Snapshot {backup_id} created successfully. Please download this file and import it on the new host: {backup_file}")\n        \n    except Exception as e:\n        logger.error(f"Error in migrate_vps: {e}")\n        await ctx.send(f"‚ùå Error during migration: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'emergency_stop\', description=\'Force stop a problematic VPS (Admin only)\')\n@app_commands.describe(\n    vps_id="ID of the VPS to stop"\n)\nasync def emergency_stop(ctx, vps_id: str):\n    """Force stop a problematic VPS (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    try:\n        token, vps = bot.db.get_vps_by_id(vps_id)\n        if not vps:\n            await ctx.send("‚ùå VPS not found!", ephemeral=True)\n            return\n\n        try:\n            container = bot.docker_client.containers.get(vps["container_id"])\n            if container.status != "running":\n                await ctx.send("VPS is already stopped!", ephemeral=True)\n                return\n            \n            await ctx.send("‚ö†Ô∏è Attempting to force stop the VPS... This may take a moment.", ephemeral=True)\n            \n            # Try normal stop first\n            try:\n                container.stop(timeout=10)\n                bot.db.update_vps(token, {\'status\': \'stopped\'})\n                await ctx.send("‚úÖ VPS stopped successfully!", ephemeral=True)\n                return\n            except:\n                pass\n            \n            # If normal stop failed, try killing the container\n            try:\n                subprocess.run(["docker", "kill", vps["container_id"]], check=True)\n                bot.db.update_vps(token, {\'status\': \'stopped\'})\n                await ctx.send("‚úÖ VPS killed forcefully!", ephemeral=True)\n            except subprocess.CalledProcessError as e:\n                raise Exception(f"Failed to kill container: {e}")\n            \n        except Exception as e:\n            await ctx.send(f"‚ùå Error stopping VPS: {str(e)}", ephemeral=True)\n    except Exception as e:\n        logger.error(f"Error in emergency_stop: {e}")\n        await ctx.send(f"‚ùå Error: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'emergency_remove\', description=\'Force remove a problematic VPS (Admin only)\')\n@app_commands.describe(\n    vps_id="ID of the VPS to remove"\n)\nasync def emergency_remove(ctx, vps_id: str):\n    """Force remove a problematic VPS (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    try:\n        token, vps = bot.db.get_vps_by_id(vps_id)\n        if not vps:\n            await ctx.send("‚ùå VPS not found!", ephemeral=True)\n            return\n\n        try:\n            # First try to stop the container\n            try:\n                container = bot.docker_client.containers.get(vps["container_id"])\n                container.stop()\n            except:\n                pass\n            \n            # Then remove it forcefully\n            try:\n                subprocess.run(["docker", "rm", "-f", vps["container_id"]], check=True)\n            except subprocess.CalledProcessError as e:\n                raise Exception(f"Failed to remove container: {e}")\n            \n            # Remove from data\n            bot.db.remove_vps(token)\n            \n            await ctx.send("‚úÖ VPS removed forcefully!", ephemeral=True)\n        except Exception as e:\n            await ctx.send(f"‚ùå Error removing VPS: {str(e)}", ephemeral=True)\n    except Exception as e:\n        logger.error(f"Error in emergency_remove: {e}")\n        await ctx.send(f"‚ùå Error: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'suspend_vps\', description=\'Suspend a VPS (Admin only)\')\n@app_commands.describe(\n    vps_id="ID of the VPS to suspend"\n)\nasync def suspend_vps(ctx, vps_id: str):\n    """Suspend a VPS (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    try:\n        token, vps = bot.db.get_vps_by_id(vps_id)\n        if not vps:\n            await ctx.send("‚ùå VPS not found!", ephemeral=True)\n            return\n\n        if vps[\'status\'] == \'suspended\':\n            await ctx.send("‚ùå VPS is already suspended!", ephemeral=True)\n            return\n\n        try:\n            container = bot.docker_client.containers.get(vps["container_id"])\n            container.stop()\n        except Exception as e:\n            logger.error(f"Error stopping container for suspend: {e}")\n\n        bot.db.update_vps(token, {\'status\': \'suspended\'})\n        await ctx.send(f"‚úÖ VPS {vps_id} has been suspended!")\n\n        # Notify owner\n        try:\n            owner = await bot.fetch_user(int(vps[\'created_by\']))\n            await owner.send(f"‚ö†Ô∏è Your VPS {vps_id} has been suspended by an admin. Contact support for details.")\n        except:\n            pass\n\n    except Exception as e:\n        logger.error(f"Error in suspend_vps: {e}")\n        await ctx.send(f"‚ùå Error suspending VPS: {str(e)}")\n\n@bot.hybrid_command(name=\'unsuspend_vps\', description=\'Unsuspend a VPS (Admin only)\')\n@app_commands.describe(\n    vps_id="ID of the VPS to unsuspend"\n)\nasync def unsuspend_vps(ctx, vps_id: str):\n    """Unsuspend a VPS (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    try:\n        token, vps = bot.db.get_vps_by_id(vps_id)\n        if not vps:\n            await ctx.send("‚ùå VPS not found!", ephemeral=True)\n            return\n\n        if vps[\'status\'] != \'suspended\':\n            await ctx.send("‚ùå VPS is not suspended!", ephemeral=True)\n            return\n\n        try:\n            container = bot.docker_client.containers.get(vps["container_id"])\n            container.start()\n        except Exception as e:\n            logger.error(f"Error starting container for unsuspend: {e}")\n            await ctx.send(f"‚ùå Error starting container: {str(e)}")\n            return\n\n        bot.db.update_vps(token, {\'status\': \'running\'})\n        await ctx.send(f"‚úÖ VPS {vps_id} has been unsuspended!")\n\n        # Notify owner\n        try:\n            owner = await bot.fetch_user(int(vps[\'created_by\']))\n            await owner.send(f"‚úÖ Your VPS {vps_id} has been unsuspended by an admin.")\n        except:\n            pass\n\n    except Exception as e:\n        logger.error(f"Error in unsuspend_vps: {e}")\n        await ctx.send(f"‚ùå Error unsuspending VPS: {str(e)}")\n\n@bot.hybrid_command(name=\'edit_vps\', description=\'Edit VPS specifications (Admin only)\')\n@app_commands.describe(\n    vps_id="ID of the VPS to edit",\n    memory="New memory in GB (optional)",\n    cpu="New CPU cores (optional)",\n    disk="New disk space in GB (optional)"\n)\nasync def edit_vps(ctx, vps_id: str, memory: Optional[int] = None, cpu: Optional[int] = None, disk: Optional[int] = None):\n    """Edit VPS specifications (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    if memory is None and cpu is None and disk is None:\n        await ctx.send("‚ùå At least one specification to edit must be provided!", ephemeral=True)\n        return\n\n    try:\n        token, vps = bot.db.get_vps_by_id(vps_id)\n        if not vps:\n            await ctx.send("‚ùå VPS not found!", ephemeral=True)\n            return\n\n        updates = {}\n        if memory is not None:\n            if memory < 1 or memory > 512:\n                await ctx.send("‚ùå Memory must be between 1GB and 512GB", ephemeral=True)\n                return\n            updates[\'memory\'] = memory\n        if cpu is not None:\n            if cpu < 1 or cpu > 32:\n                await ctx.send("‚ùå CPU cores must be between 1 and 32", ephemeral=True)\n                return\n            updates[\'cpu\'] = cpu\n        if disk is not None:\n            if disk < 10 or disk > 1000:\n                await ctx.send("‚ùå Disk space must be between 10GB and 1000GB", ephemeral=True)\n                return\n            updates[\'disk\'] = disk\n\n        # Restart container with new limits\n        try:\n            container = bot.docker_client.containers.get(vps["container_id"])\n            container.stop()\n            container.remove()\n\n            memory_bytes = (memory or vps[\'memory\']) * 1024 * 1024 * 1024\n            cpu_quota = int((cpu or vps[\'cpu\']) * 100000)\n\n            new_container = bot.docker_client.containers.run(\n                vps[\'os_image\'],\n                detach=True,\n                privileged=True,\n                hostname=f"hostforge-{vps_id}",\n                mem_limit=memory_bytes,\n                cpu_period=100000,\n                cpu_quota=cpu_quota,\n                cap_add=["ALL"],\n                command="tail -f /dev/null",\n                tty=True,\n                network=DOCKER_NETWORK,\n                ports={\'22/tcp\': str(vps[\'external_ssh_port\'])},\n                volumes={\n                    f\'hostforge-{vps_id}\': {\'bind\': \'/data\', \'mode\': \'rw\'}\n                },\n                restart_policy={"Name": "always"}\n            )\n\n            updates[\'container_id\'] = new_container.id\n            await asyncio.sleep(5)\n            setup_success, _ = await setup_container(\n                new_container.id, \n                ctx, \n                memory or vps[\'memory\'], \n                vps_id=vps_id,\n                use_custom_image=vps[\'use_custom_image\']\n            )\n            if not setup_success:\n                raise Exception("Failed to setup new container")\n        except Exception as e:\n            await ctx.send(f"‚ùå Error updating container: {str(e)}")\n            return\n\n        bot.db.update_vps(token, updates)\n        await ctx.send(f"‚úÖ VPS {vps_id} specifications updated successfully!")\n\n    except Exception as e:\n        logger.error(f"Error in edit_vps: {e}")\n        await ctx.send(f"‚ùå Error editing VPS: {str(e)}")\n\n@bot.hybrid_command(name=\'ban_user\', description=\'Ban a user from creating VPS (Admin only)\')\n@app_commands.describe(\n    user="User to ban"\n)\nasync def ban_user(ctx, user: discord.User):\n    """Ban a user from creating VPS (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    bot.db.ban_user(user.id)\n    await ctx.send(f"‚úÖ {user.mention} has been banned from creating VPS!")\n\n@bot.hybrid_command(name=\'unban_user\', description=\'Unban a user (Admin only)\')\n@app_commands.describe(\n    user="User to unban"\n)\nasync def unban_user(ctx, user: discord.User):\n    """Unban a user (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    bot.db.unban_user(user.id)\n    await ctx.send(f"‚úÖ {user.mention} has been unbanned!")\n\n@bot.hybrid_command(name=\'list_banned\', description=\'List banned users (Admin only)\')\nasync def list_banned(ctx):\n    """List banned users (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    banned = bot.db.get_banned_users()\n    if not banned:\n        await ctx.send("No banned users.", ephemeral=True)\n        return\n\n    embed = discord.Embed(title="Banned Users", color=discord.Color.red())\n    banned_list = []\n    for user_id in banned:\n        try:\n            user = await bot.fetch_user(int(user_id))\n            banned_list.append(f"{user.name} ({user_id})")\n        except:\n            banned_list.append(f"Unknown ({user_id})")\n    embed.description = "\\n".join(banned_list)\n    await ctx.send(embed=embed, ephemeral=True)\n\n@bot.hybrid_command(name=\'backup_data\', description=\'Backup all bot data (Admin only)\')\nasync def backup_data(ctx):\n    """Backup all bot data (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    try:\n        if bot.db.backup_data():\n            await ctx.send("‚úÖ Data backup completed successfully!", ephemeral=True)\n        else:\n            await ctx.send("‚ùå Failed to backup data!", ephemeral=True)\n    except Exception as e:\n        logger.error(f"Error in backup_data: {e}")\n        await ctx.send(f"‚ùå Error backing up data: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'restore_data\', description=\'Restore from backup (Admin only)\')\nasync def restore_data(ctx):\n    """Restore from backup (Admin only)"""\n    if not has_admin_role(ctx):\n        await ctx.send("‚ùå You must be an admin to use this command!", ephemeral=True)\n        return\n\n    try:\n        if bot.db.restore_data():\n            await ctx.send("‚úÖ Data restore completed successfully!", ephemeral=True)\n        else:\n            await ctx.send("‚ùå Failed to restore data!", ephemeral=True)\n    except Exception as e:\n        logger.error(f"Error in restore_data: {e}")\n        await ctx.send(f"‚ùå Error restoring data: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'reinstall_bot\', description=\'Reinstall the bot (Owner only)\')\nasync def reinstall_bot(ctx):\n    """Reinstall the bot (Owner only)"""\n    if ctx.author.id != 1210291131301101618:  # Only the owner can reinstall\n        await ctx.send("‚ùå Only the owner can reinstall the bot!", ephemeral=True)\n        return\n\n    try:\n        await ctx.send("üîÑ Reinstalling HostForge bot... This may take a few minutes.")\n        \n        # Create Dockerfile for bot reinstallation\n        dockerfile_content = f"""\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    docker.io \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Copy requirements and install Python dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy bot code\nCOPY . .\n\n# Start the bot\nCMD ["python", "bot.py"]\n"""\n        \n        with open("Dockerfile.bot", "w") as f:\n            f.write(dockerfile_content)\n        \n        # Build and run the bot in a container\n        process = await asyncio.create_subprocess_exec(\n            "docker", "build", "-t", "hostforge-bot", "-f", "Dockerfile.bot", ".",\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE\n        )\n        \n        stdout, stderr = await process.communicate()\n        \n        if process.returncode != 0:\n            raise Exception(f"Failed to build bot image: {stderr.decode()}")\n        \n        await ctx.send("‚úÖ Bot reinstalled successfully! Restarting...")\n        \n        # Restart the bot\n        os._exit(0)\n        \n    except Exception as e:\n        logger.error(f"Error in reinstall_bot: {e}")\n        await ctx.send(f"‚ùå Error reinstalling bot: {str(e)}", ephemeral=True)\n\nclass VPSManagementView(ui.View):\n    def __init__(self, vps_id, container_id):\n        super().__init__(timeout=300)\n        self.vps_id = vps_id\n        self.container_id = container_id\n        self.original_message = None\n\n    async def handle_missing_container(self, interaction: discord.Interaction):\n        token, _ = bot.db.get_vps_by_id(self.vps_id)\n        if token:\n            bot.db.remove_vps(token)\n        \n        embed = discord.Embed(title=f"HostForge VPS Management - {self.vps_id}", color=discord.Color.red())\n        embed.add_field(name="Status", value="üî¥ Container Not Found", inline=True)\n        embed.add_field(name="Note", value="This VPS instance is no longer available. Please create a new one.", inline=False)\n        \n        for item in self.children:\n            item.disabled = True\n        \n        await interaction.message.edit(embed=embed, view=self)\n        await interaction.response.send_message("‚ùå This VPS instance is no longer available. Please create a new one.", ephemeral=True)\n\n    @discord.ui.button(label="Start VPS", style=discord.ButtonStyle.green)\n    async def start_vps(self, interaction: discord.Interaction, button: discord.ui.Button):\n        try:\n            await interaction.response.defer(ephemeral=True)\n            \n            try:\n                container = bot.docker_client.containers.get(self.container_id)\n            except docker.errors.NotFound:\n                await self.handle_missing_container(interaction)\n                return\n            \n            token, vps = bot.db.get_vps_by_id(self.vps_id)\n            if vps[\'status\'] == \'suspended\':\n                await interaction.followup.send("‚ùå This VPS is suspended. Contact admin to unsuspend.", ephemeral=True)\n                return\n\n            if container.status == "running":\n                await interaction.followup.send("VPS is already running!", ephemeral=True)\n                return\n            \n            container.start()\n            await asyncio.sleep(5)\n            \n            if token:\n                bot.db.update_vps(token, {\'status\': \'running\'})\n            \n            embed = discord.Embed(title=f"HostForge VPS Management - {self.vps_id}", color=discord.Color.green())\n            embed.add_field(name="Status", value="üü¢ Running", inline=True)\n            \n            if vps:\n                embed.add_field(name="Memory", value=f"{vps[\'memory\']}GB", inline=True)\n                embed.add_field(name="CPU", value=f"{vps[\'cpu\']} cores", inline=True)\n                embed.add_field(name="Disk", value=f"{vps[\'disk\']}GB", inline=True)\n                embed.add_field(name="Username", value=vps[\'username\'], inline=True)\n                embed.add_field(name="Created", value=vps[\'created_at\'], inline=True)\n            \n            await interaction.message.edit(embed=embed)\n            await interaction.followup.send("‚úÖ HostForge VPS started successfully!", ephemeral=True)\n        except Exception as e:\n            await interaction.followup.send(f"‚ùå Error starting VPS: {str(e)}", ephemeral=True)\n\n    @discord.ui.button(label="Stop VPS", style=discord.ButtonStyle.red)\n    async def stop_vps(self, interaction: discord.Interaction, button: discord.ui.Button):\n        try:\n            await interaction.response.defer(ephemeral=True)\n            \n            try:\n                container = bot.docker_client.containers.get(self.container_id)\n            except docker.errors.NotFound:\n                await self.handle_missing_container(interaction)\n                return\n            \n            if container.status != "running":\n                await interaction.followup.send("VPS is already stopped!", ephemeral=True)\n                return\n            \n            container.stop()\n            \n            token, vps = bot.db.get_vps_by_id(self.vps_id)\n            if token:\n                bot.db.update_vps(token, {\'status\': \'stopped\'})\n            \n            embed = discord.Embed(title=f"HostForge VPS Management - {self.vps_id}", color=discord.Color.orange())\n            embed.add_field(name="Status", value="üî¥ Stopped", inline=True)\n            \n            if vps:\n                embed.add_field(name="Memory", value=f"{vps[\'memory\']}GB", inline=True)\n                embed.add_field(name="CPU", value=f"{vps[\'cpu\']} cores", inline=True)\n                embed.add_field(name="Disk", value=f"{vps[\'disk\']}GB", inline=True)\n                embed.add_field(name="Username", value=vps[\'username\'], inline=True)\n                embed.add_field(name="Created", value=vps[\'created_at\'], inline=True)\n            \n            await interaction.message.edit(embed=embed)\n            await interaction.followup.send("‚úÖ HostForge VPS stopped successfully!", ephemeral=True)\n        except Exception as e:\n            await interaction.followup.send(f"‚ùå Error stopping VPS: {str(e)}", ephemeral=True)\n\n    @discord.ui.button(label="Restart VPS", style=discord.ButtonStyle.blurple)\n    async def restart_vps(self, interaction: discord.Interaction, button: discord.ui.Button):\n        try:\n            await interaction.response.defer(ephemeral=True)\n            \n            try:\n                container = bot.docker_client.containers.get(self.container_id)\n            except docker.errors.NotFound:\n                await self.handle_missing_container(interaction)\n                return\n            \n            token, vps = bot.db.get_vps_by_id(self.vps_id)\n            if vps[\'status\'] == \'suspended\':\n                await interaction.followup.send("‚ùå This VPS is suspended. Contact admin to unsuspend.", ephemeral=True)\n                return\n\n            container.restart()\n            await asyncio.sleep(5)\n            \n            # Update restart count in VPS data\n            if token:\n                updates = {\n                    \'restart_count\': vps.get(\'restart_count\', 0) + 1,\n                    \'last_restart\': str(datetime.datetime.now()),\n                    \'status\': \'running\'\n                }\n                bot.db.update_vps(token, updates)\n                \n                bot.db.increment_stat(\'total_restarts\')\n                \n                # Get new SSH session\n                try:\n                    exec_cmd = await asyncio.create_subprocess_exec(\n                        "docker", "exec", self.container_id, "tmate", "-F",\n                        stdout=asyncio.subprocess.PIPE,\n                        stderr=asyncio.subprocess.PIPE\n                    )\n\n                    ssh_session_line = await capture_ssh_session_line(exec_cmd)\n                    if ssh_session_line:\n                        bot.db.update_vps(token, {\'tmate_session\': ssh_session_line})\n                        \n                        # Send new SSH details to owner\n                        try:\n                            owner = await bot.fetch_user(int(vps["created_by"]))\n                            embed = discord.Embed(title=f"HostForge VPS Restarted - {self.vps_id}", color=discord.Color.blue())\n                            embed.add_field(name="New SSH Session", value=f"```{ssh_session_line}```", inline=False)\n                            embed.add_field(name="Direct SSH", value=f"```ssh root@{bot.public_ip} -p {vps[\'external_ssh_port\']}```", inline=False)\n                            await owner.send(embed=embed)\n                        except:\n                            pass\n                except:\n                    pass\n            \n            embed = discord.Embed(title=f"HostForge VPS Management - {self.vps_id}", color=discord.Color.green())\n            embed.add_field(name="Status", value="üü¢ Running", inline=True)\n            \n            if vps:\n                embed.add_field(name="Memory", value=f"{vps[\'memory\']}GB", inline=True)\n                embed.add_field(name="CPU", value=f"{vps[\'cpu\']} cores", inline=True)\n                embed.add_field(name="Disk", value=f"{vps[\'disk\']}GB", inline=True)\n                embed.add_field(name="Username", value=vps[\'username\'], inline=True)\n                embed.add_field(name="Created", value=vps[\'created_at\'], inline=True)\n                embed.add_field(name="Restart Count", value=vps.get(\'restart_count\', 0) + 1, inline=True)\n            \n            await interaction.message.edit(embed=embed, view=VPSManagementView(self.vps_id, container.id))\n            await interaction.followup.send("‚úÖ HostForge VPS restarted successfully! New SSH details sent to owner.", ephemeral=True)\n        except Exception as e:\n            await interaction.followup.send(f"‚ùå Error restarting VPS: {str(e)}", ephemeral=True)\n\n    @discord.ui.button(label="Reinstall OS", style=discord.ButtonStyle.grey)\n    async def reinstall_os(self, interaction: discord.Interaction, button: discord.ui.Button):\n        try:\n            try:\n                container = bot.docker_client.containers.get(self.container_id)\n            except docker.errors.NotFound:\n                await self.handle_missing_container(interaction)\n                return\n            \n            view = OSSelectionView(self.vps_id, self.container_id, interaction.message)\n            await interaction.response.send_message("Select new OS:", view=view, ephemeral=True)\n        except Exception as e:\n            await interaction.response.send_message(f"‚ùå Error: {str(e)}", ephemeral=True)\n\n    @discord.ui.button(label="Transfer VPS", style=discord.ButtonStyle.grey)\n    async def transfer_vps(self, interaction: discord.Interaction, button: discord.ui.Button):\n        modal = TransferVPSModal(self.vps_id)\n        await interaction.response.send_modal(modal)\n\nclass OSSelectionView(ui.View):\n    def __init__(self, vps_id, container_id, original_message):\n        super().__init__(timeout=300)\n        self.vps_id = vps_id\n        self.container_id = container_id\n        self.original_message = original_message\n        \n        self.add_os_button("Ubuntu 22.04", "ubuntu:22.04")\n        self.add_os_button("Debian 12", "debian:12")\n        self.add_os_button("Arch Linux", "archlinux:latest")\n        self.add_os_button("Alpine", "alpine:latest")\n        self.add_os_button("CentOS 7", "centos:7")\n        self.add_os_button("Fedora 38", "fedora:38")\n\n    def add_os_button(self, label: str, image: str):\n        button = discord.ui.Button(label=label, style=discord.ButtonStyle.grey)\n        \n        async def os_callback(interaction: discord.Interaction):\n            await self.reinstall_os(interaction, image)\n        \n        button.callback = os_callback\n        self.add_item(button)\n\n    async def reinstall_os(self, interaction: discord.Interaction, image: str):\n        try:\n            token, vps = bot.db.get_vps_by_id(self.vps_id)\n            if not vps:\n                await interaction.response.send_message("‚ùå VPS not found!", ephemeral=True)\n                return\n\n            await interaction.response.defer(ephemeral=True)\n\n            try:\n                old_container = bot.docker_client.containers.get(self.container_id)\n                old_container.stop()\n                old_container.remove()\n            except Exception as e:\n                logger.error(f"Error removing old container: {e}")\n\n            status_msg = await interaction.followup.send("üîÑ Reinstalling HostForge VPS... This may take a few minutes.", ephemeral=True)\n            \n            memory_bytes = vps[\'memory\'] * 1024 * 1024 * 1024\n\n            try:\n                container = bot.docker_client.containers.run(\n                    image,\n                    detach=True,\n                    privileged=True,\n                    hostname=f"hostforge-{self.vps_id}",\n                    mem_limit=memory_bytes,\n                    cpu_period=100000,\n                    cpu_quota=int(vps[\'cpu\'] * 100000),\n                    cap_add=["ALL"],\n                    command="tail -f /dev/null",\n                    tty=True,\n                    network=DOCKER_NETWORK,\n                    ports={\'22/tcp\': str(vps[\'external_ssh_port\'])},\n                    volumes={\n                        f\'hostforge-{self.vps_id}\': {\'bind\': \'/data\', \'mode\': \'rw\'}\n                    }\n                )\n            except docker.errors.ImageNotFound:\n                await status_msg.edit(content=f"‚ùå OS image {image} not found. Using default {DEFAULT_OS_IMAGE}")\n                container = bot.docker_client.containers.run(\n                    DEFAULT_OS_IMAGE,\n                    detach=True,\n                    privileged=True,\n                    hostname=f"hostforge-{self.vps_id}",\n                    mem_limit=memory_bytes,\n                    cpu_period=100000,\n                    cpu_quota=int(vps[\'cpu\'] * 100000),\n                    cap_add=["ALL"],\n                    command="tail -f /dev/null",\n                    tty=True,\n                    network=DOCKER_NETWORK,\n                    ports={\'22/tcp\': str(vps[\'external_ssh_port\'])},\n                    volumes={\n                        f\'hostforge-{self.vps_id}\': {\'bind\': \'/data\', \'mode\': \'rw\'}\n                    }\n                )\n                image = DEFAULT_OS_IMAGE\n\n            bot.db.update_vps(token, {\n                \'container_id\': container.id,\n                \'os_image\': image\n            })\n\n            try:\n                setup_success, _ = await setup_container(\n                    container.id, \n                    status_msg, \n                    vps[\'memory\'], \n                    vps_id=self.vps_id\n                )\n                if not setup_success:\n                    raise Exception("Failed to setup container")\n                \n                bot.db.update_vps(token, {\'password\': "root"})\n            except Exception as e:\n                await status_msg.edit(content=f"‚ùå Container setup failed: {str(e)}")\n                return\n\n            try:\n                exec_cmd = await asyncio.create_subprocess_exec(\n                    "docker", "exec", container.id, "tmate", "-F",\n                    stdout=asyncio.subprocess.PIPE,\n                    stderr=asyncio.subprocess.PIPE\n                )\n\n                ssh_session_line = await capture_ssh_session_line(exec_cmd)\n                if ssh_session_line:\n                    bot.db.update_vps(token, {\'tmate_session\': ssh_session_line})\n                    \n                    # Send new SSH details to owner\n                    try:\n                        owner = await bot.fetch_user(int(vps["created_by"]))\n                        embed = discord.Embed(title=f"HostForge VPS Reinstalled - {self.vps_id}", color=discord.Color.blue())\n                        embed.add_field(name="New OS", value=image, inline=True)\n                        embed.add_field(name="New SSH Session", value=f"```{ssh_session_line}```", inline=False)\n                        embed.add_field(name="Direct SSH", value=f"```ssh root@{bot.public_ip} -p {vps[\'external_ssh_port\']}```", inline=False)\n                        embed.add_field(name="Password", value=f"||root||", inline=False)\n                        await owner.send(embed=embed)\n                    except:\n                        pass\n            except Exception as e:\n                logger.error(f"Warning: Failed to start tmate session: {e}")\n\n            await status_msg.edit(content="‚úÖ HostForge VPS reinstalled successfully!")\n            \n            try:\n                embed = discord.Embed(title=f"HostForge VPS Management - {self.vps_id}", color=discord.Color.green())\n                embed.add_field(name="Status", value="üü¢ Running", inline=True)\n                embed.add_field(name="Memory", value=f"{vps[\'memory\']}GB", inline=True)\n                embed.add_field(name="CPU", value=f"{vps[\'cpu\']} cores", inline=True)\n                embed.add_field(name="Disk", value=f"{vps[\'disk\']}GB", inline=True)\n                embed.add_field(name="Username", value="root", inline=True)\n                embed.add_field(name="Created", value=vps[\'created_at\'], inline=True)\n                embed.add_field(name="OS", value=image, inline=True)\n                \n                await self.original_message.edit(embed=embed, view=VPSManagementView(self.vps_id, container.id))\n            except Exception as e:\n                logger.error(f"Warning: Failed to update original message: {e}")\n\n        except Exception as e:\n            try:\n                await interaction.followup.send(f"‚ùå Error reinstalling VPS: {str(e)}", ephemeral=True)\n            except:\n                try:\n                    channel = interaction.channel\n                    await channel.send(f"‚ùå Error reinstalling HostForge VPS {self.vps_id}: {str(e)}")\n                except:\n                    logger.error(f"Failed to send error message: {e}")\n\n    async def on_timeout(self):\n        for item in self.children:\n            item.disabled = True\n        try:\n            await self.original_message.edit(view=self)\n        except:\n            pass\n\nclass TransferVPSModal(ui.Modal, title=\'Transfer VPS\'):\n    def __init__(self, vps_id: str):\n        super().__init__()\n        self.vps_id = vps_id\n        self.new_owner = ui.TextInput(\n            label=\'New Owner\',\n            placeholder=\'Enter user ID or @mention\',\n            required=True\n        )\n        self.add_item(self.new_owner)\n\n    async def on_submit(self, interaction: discord.Interaction):\n        try:\n            new_owner_input = self.new_owner.value.strip()\n            \n            # Extract user ID from mention if provided\n            if new_owner_input.startswith(\'<@\') and new_owner_input.endswith(\'>\'):\n                new_owner_id = new_owner_input[2:-1]\n                if new_owner_id.startswith(\'!\'):  # Handle nickname mentions\n                    new_owner_id = new_owner_id[1:]\n            else:\n                # Validate it\'s a numeric ID\n                if not new_owner_input.isdigit():\n                    await interaction.response.send_message("‚ùå Please provide a valid user ID or @mention", ephemeral=True)\n                    return\n                new_owner_id = new_owner_input\n\n            token, vps = bot.db.get_vps_by_id(self.vps_id)\n            if not vps or vps["created_by"] != str(interaction.user.id):\n                await interaction.response.send_message("‚ùå VPS not found or you don\'t have permission to transfer it!", ephemeral=True)\n                return\n\n            try:\n                old_owner = await bot.fetch_user(int(vps["created_by"]))\n                old_owner_name = old_owner.name\n            except:\n                old_owner_name = "Unknown User"\n\n            try:\n                new_owner = await bot.fetch_user(int(new_owner_id))\n                new_owner_name = new_owner.name\n                \n                # Check if new owner is banned\n                if bot.db.is_user_banned(new_owner.id):\n                    await interaction.response.send_message(f"‚ùå {new_owner.mention} is banned!", ephemeral=True)\n                    return\n\n                # Check if new owner already has max VPS\n                if bot.db.get_user_vps_count(new_owner.id) >= bot.db.get_setting(\'max_vps_per_user\'):\n                    await interaction.response.send_message(f"‚ùå {new_owner.mention} already has the maximum number of VPS instances ({bot.db.get_setting(\'max_vps_per_user\')})", ephemeral=True)\n                    return\n            except:\n                await interaction.response.send_message("‚ùå Invalid user ID or mention!", ephemeral=True)\n                return\n\n            bot.db.update_vps(token, {"created_by": str(new_owner.id)})\n\n            await interaction.response.send_message(f"‚úÖ HostForge VPS {self.vps_id} has been transferred from {old_owner_name} to {new_owner_name}!", ephemeral=True)\n            \n            try:\n                embed = discord.Embed(title="HostForge VPS Transferred to You", color=discord.Color.green())\n                embed.add_field(name="VPS ID", value=self.vps_id, inline=True)\n                embed.add_field(name="Previous Owner", value=old_owner_name, inline=True)\n                embed.add_field(name="Memory", value=f"{vps[\'memory\']}GB", inline=True)\n                embed.add_field(name="CPU", value=f"{vps[\'cpu\']} cores", inline=True)\n                embed.add_field(name="Disk", value=f"{vps[\'disk\']}GB", inline=True)\n                embed.add_field(name="Username", value="root", inline=True)\n                embed.add_field(name="Access Token", value=token, inline=False)\n                embed.add_field(name="SSH Password", value=f"||root||", inline=False)\n                embed.add_field(name="Direct SSH", value=f"```ssh root@{bot.public_ip} -p {vps[\'external_ssh_port\']}```", inline=False)\n                await new_owner.send(embed=embed)\n            except:\n                await interaction.followup.send("Note: Could not send DM to the new owner.", ephemeral=True)\n\n        except Exception as e:\n            logger.error(f"Error in TransferVPSModal: {e}")\n            await interaction.response.send_message(f"‚ùå Error transferring VPS: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'manage_vps\', description=\'Manage a VPS instance\')\n@app_commands.describe(\n    vps_id="ID of the VPS to manage"\n)\nasync def manage_vps(ctx, vps_id: str):\n    """Manage a VPS instance"""\n    try:\n        token, vps = bot.db.get_vps_by_id(vps_id)\n        if not vps or (vps["created_by"] != str(ctx.author.id) and not has_admin_role(ctx)):\n            await ctx.send("‚ùå VPS not found or you don\'t have access to it!", ephemeral=True)\n            return\n\n        try:\n            container = bot.docker_client.containers.get(vps["container_id"])\n            container_status = container.status.capitalize()\n        except:\n            container_status = "Not Found"\n\n        status = vps[\'status\'].capitalize()\n\n        embed = discord.Embed(title=f"HostForge VPS Management - {vps_id}", color=discord.Color.blue())\n        embed.add_field(name="Status", value=f"{status} (Container: {container_status})", inline=True)\n        embed.add_field(name="Memory", value=f"{vps[\'memory\']}GB", inline=True)\n        embed.add_field(name="CPU", value=f"{vps[\'cpu\']} cores", inline=True)\n        embed.add_field(name="Disk Allocated", value=f"{vps[\'disk\']}GB", inline=True)\n        embed.add_field(name="Username", value="root", inline=True)\n        embed.add_field(name="Created", value=vps[\'created_at\'], inline=True)\n        embed.add_field(name="OS", value=vps.get(\'os_image\', DEFAULT_OS_IMAGE), inline=True)\n        embed.add_field(name="Restart Count", value=vps.get(\'restart_count\', 0), inline=True)\n        embed.add_field(name="SSH Port", value=vps[\'external_ssh_port\'], inline=True)\n\n        view = VPSManagementView(vps_id, vps["container_id"])\n        \n        message = await ctx.send(embed=embed, view=view)\n        view.original_message = message\n    except Exception as e:\n        logger.error(f"Error in manage_vps: {e}")\n        await ctx.send(f"‚ùå Error managing VPS: {str(e)}", ephemeral=True)\n\n@bot.hybrid_command(name=\'transfer_vps\', description=\'Transfer a VPS to another user\')\n@app_commands.describe(\n    vps_id="ID of the VPS to transfer",\n    new_owner="User to transfer the VPS to"\n)\nasync def transfer_vps_command(ctx, vps_id: str, new_owner: discord.Member):\n    """Transfer a VPS to another user"""\n    try:\n        token, vps = bot.db.get_vps_by_id(vps_id)\n        if not vps or vps["created_by"] != str(ctx.author.id):\n            await ctx.send("‚ùå VPS not found or you don\'t have permission to transfer it!", ephemeral=True)\n            return\n\n        if bot.db.is_user_banned(new_owner.id):\n            await ctx.send("‚ùå This user is banned!", ephemeral=True)\n            return\n\n        # Check if new owner already has max VPS\n        if bot.db.get_user_vps_count(new_owner.id) >= bot.db.get_setting(\'max_vps_per_user\'):\n            await ctx.send(f"‚ùå {new_owner.mention} already has the maximum number of VPS instances ({bot.db.get_setting(\'max_vps_per_user\')})", ephemeral=True)\n            return\n\n        bot.db.update_vps(token, {"created_by": str(new_owner.id)})\n\n        await ctx.send(f"‚úÖ HostForge VPS {vps_id} has been transferred from {ctx.author.name} to {new_owner.name}!")\n\n        try:\n            embed = discord.Embed(title="HostForge VPS Transferred to You", color=discord.Color.green())\n            embed.add_field(name="VPS ID", value=vps_id, inline=True)\n            embed.add_field(name="Previous Owner", value=ctx.author.name, inline=True)\n            embed.add_field(name="Memory", value=f"{vps[\'memory\']}GB", inline=True)\n            embed.add_field(name="CPU", value=f"{vps[\'cpu\']} cores", inline=True)\n            embed.add_field(name="Disk", value=f"{vps[\'disk\']}GB", inline=True)\n            embed.add_field(name="Username", value="root", inline=True)\n            embed.add_field(name="Access Token", value=token, inline=False)\n            embed.add_field(name="SSH Password", value=f"||root||", inline=False)\n            embed.add_field(name="Direct SSH", value=f"```ssh root@{bot.public_ip} -p {vps[\'external_ssh_port\']}```", inline=False)\n            await new_owner.send(embed=embed)\n        except:\n            await ctx.send("Note: Could not send DM to the new owner.", ephemeral=True)\n\n    except Exception as e:\n        logger.error(f"Error in transfer_vps_command: {e}")\n        await ctx.send(f"‚ùå Error transferring VPS: {str(e)}", ephemeral=True)\n\n@bot.event\nasync def on_command_error(ctx, error):\n    if isinstance(error, commands.CheckFailure):\n        await ctx.send("‚ùå You don\'t have permission to use this command!", ephemeral=True)\n    elif isinstance(error, commands.CommandNotFound):\n        await ctx.send("‚ùå Command not found! Use `/help` to see available commands.", ephemeral=True)\n    elif isinstance(error, commands.MissingRequiredArgument):\n        await ctx.send(f"‚ùå Missing required argument: {error.param.name}", ephemeral=True)\n    else:\n        logger.error(f"Command error: {error}")\n        await ctx.send(f"‚ùå An error occurred: {str(error)}", ephemeral=True)\n\n# Run the bot\nif __name__ == "__main__":\n    try:\n        # Create directories if they don\'t exist\n        os.makedirs("temp_dockerfiles", exist_ok=True)\n        os.makedirs("migrations", exist_ok=True)\n        \n        bot.run(TOKEN)\n    except Exception as e:\n        logger.error(f"Bot crashed: {e}")\n        traceback.print_exc()'.replace("unixnode", company)
with open("bot.py", "w", encoding="utf-8") as f:
    f.write(bot_code)

# Write .env
env_code = 'DISCORD_TOKEN=your_discord_bot_token_here\nADMIN_IDS=1210291131301101618\nADMIN_ROLE_ID=1376177459870961694\nDEFAULT_OS_IMAGE=ubuntu:22.04\nDOCKER_NETWORK=bridge\nMAX_CONTAINERS=100\nMAX_VPS_PER_USER=3'
env_code = re.sub(r"DISCORD_TOKEN=.*", f"DISCORD_TOKEN={discord_token}", env_code)
env_code = re.sub(r"ADMIN_IDS=.*", f"ADMIN_IDS={admin_id}", env_code)
env_code = re.sub(r"ADMIN_ROLE_ID=.*", f"ADMIN_ROLE_ID={admin_role}", env_code)

with open("1.env", "w", encoding="utf-8") as f:
    f.write(env_code)

print("Setup complete. Starting bot...")

subprocess.run([sys.executable, "bot.py"])
